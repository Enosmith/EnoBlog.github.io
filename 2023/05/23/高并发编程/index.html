<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高并发编程 | 小灰灰的博客</title><meta name="author" content="邓晖"><meta name="copyright" content="邓晖"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="线程线程的生命周期  NEW：初始状态，线程被构建，但是还没有调用start()方法。  RUNNABLE：可运行状态，可运行状态可以包括：运行中状态和就绪状态。    BLOCKED：阻塞状态，处于这个状态的线程需要等待其他线程释放锁或者等待进入synchronized。  WAITING：表示等待状态，处于该状态的线程需要等待其他线程对其进行通知或中断等操作，进而进入下一个状态。  TIME_">
<meta property="og:type" content="article">
<meta property="og:title" content="高并发编程">
<meta property="og:url" content="http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="小灰灰的博客">
<meta property="og:description" content="线程线程的生命周期  NEW：初始状态，线程被构建，但是还没有调用start()方法。  RUNNABLE：可运行状态，可运行状态可以包括：运行中状态和就绪状态。    BLOCKED：阻塞状态，处于这个状态的线程需要等待其他线程释放锁或者等待进入synchronized。  WAITING：表示等待状态，处于该状态的线程需要等待其他线程对其进行通知或中断等操作，进而进入下一个状态。  TIME_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/cover.jpg">
<meta property="article:published_time" content="2023-05-23T09:03:25.000Z">
<meta property="article:modified_time" content="2024-02-10T08:32:18.873Z">
<meta property="article:author" content="邓晖">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/cover.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-10 16:32:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-linkindex_img"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="小灰灰的博客"><img class="site-icon" src="/img/logo.png"/><span class="site-name">小灰灰的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-linkindex_img"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-23T09:03:25.000Z" title="Created 2023-05-23 17:03:25">2023-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-10T08:32:18.873Z" title="Updated 2024-02-10 16:32:18">2024-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230524110023325.png" alt="image-20230524110023325"></p>
<ul>
<li><p>NEW：初始状态，线程被构建，但是还没有调用start()方法。</p>
</li>
<li><p>RUNNABLE：可运行状态，可运行状态可以包括：运行中状态和就绪状态。  </p>
</li>
<li><p>BLOCKED：阻塞状态，处于这个状态的线程需要等待其他线程释放锁或者等待进入synchronized。</p>
</li>
<li><p>WAITING：表示等待状态，处于该状态的线程需要等待其他线程对其进行通知或中断等操作，进而进入下一个状态。</p>
</li>
<li><p>TIME_WAITING：超时等待状态。可以在一定的时间自行返回。</p>
</li>
<li><p>TERMINATED：终止状态，当前线程执行完毕。</p>
</li>
</ul>
<p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230524112927002.png" alt="image-20230524112927002"></p>
<p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230524112957888.png" alt="image-20230524112957888"></p>
<blockquote>
<p>TimeUnit.SECONDS.sleep(seconds); &#x2F;&#x2F; 也可以这么进行睡眠</p>
</blockquote>
<blockquote>
<p>new Thread(new WaitingTime(), “WaitingTimeThread”).start();  &#x2F;&#x2F;也可这么赋值线程名</p>
</blockquote>
<h3 id="利用命令行查询线程状态"><a href="#利用命令行查询线程状态" class="headerlink" title="利用命令行查询线程状态"></a>利用命令行查询线程状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;jps</span><br><span class="line">21584 Jps</span><br><span class="line">17828 KotlinCompileDaemon</span><br><span class="line">12284 Launcher</span><br><span class="line">24572</span><br><span class="line">28492 ThreadState</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;jstack 28492</span><br><span class="line">2020-02-15 00:27:08</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.202-b08 mixed mode):</span><br><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> <span class="comment">#16 prio=5 os_prio=0 tid=0x000000001ca05000 nid=0x1a4 waiting on condition</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;BlockedThread-02&quot;</span> <span class="comment">#15 prio=5 os_prio=0 tid=0x000000001ca04800 nid=0x6eb0 waiting for monitor entry</span></span><br><span class="line">[0x000000001da4f000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at io.binghe.concurrent.executor.state.BlockedThread.run(BlockedThread.java:28)</span><br><span class="line">- waiting to lock &lt;0x0000000780a7e4e8&gt; (a java.lang.Class <span class="keyword">for</span></span><br><span class="line">io.binghe.concurrent.executor.state.BlockedThread)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">&quot;BlockedThread-01&quot;</span> <span class="comment">#14 prio=5 os_prio=0 tid=0x000000001ca01800 nid=0x6e28 waiting on condition</span></span><br><span class="line">[0x000000001d94f000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line">at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.<span class="built_in">sleep</span>(TimeUnit.java:386)</span><br><span class="line">at io.binghe.concurrent.executor.state.WaitingTime.waitSecond(WaitingTime.java:36)</span><br><span class="line">at io.binghe.concurrent.executor.state.BlockedThread.run(BlockedThread.java:28)</span><br><span class="line">- locked &lt;0x0000000780a7e4e8&gt; (a java.lang.Class <span class="keyword">for</span></span><br><span class="line">io.binghe.concurrent.executor.state.BlockedThread)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">&quot;WaitingStateThread&quot;</span> <span class="comment">#13 prio=5 os_prio=0 tid=0x000000001ca06000 nid=0x6fe4 in Object.wait()</span></span><br><span class="line">[0x000000001d84f000]</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.<span class="built_in">wait</span>(Native Method)</span><br><span class="line">- waiting on &lt;0x0000000780a7b488&gt; (a java.lang.Class <span class="keyword">for</span></span><br><span class="line">io.binghe.concurrent.executor.state.WaitingState)</span><br><span class="line">at java.lang.Object.<span class="built_in">wait</span>(Object.java:502)</span><br><span class="line">at io.binghe.concurrent.executor.state.WaitingState.run(WaitingState.java:29)</span><br><span class="line">- locked &lt;0x0000000780a7b488&gt; (a java.lang.Class <span class="keyword">for</span></span><br><span class="line">io.binghe.concurrent.executor.state.WaitingState)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">&quot;WaitingTimeThread&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001c9f8800 nid=0x3858 waiting on condition</span></span><br><span class="line">[0x000000001d74f000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line">at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.<span class="built_in">sleep</span>(TimeUnit.java:386)</span><br><span class="line">at io.binghe.concurrent.executor.state.WaitingTime.waitSecond(WaitingTime.java:36)</span><br><span class="line">at io.binghe.concurrent.executor.state.WaitingTime.run(WaitingTime.java:29)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"><span class="string">&quot;Service Thread&quot;</span> <span class="comment">#11 daemon prio=9 os_prio=0 tid=0x000000001c935000 nid=0x6864 runnable</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;C1 CompilerThread3&quot;</span> <span class="comment">#10 daemon prio=9 os_prio=2 tid=0x000000001c88c800 nid=0x6a28 waiting on condition</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;C2 CompilerThread2&quot;</span> <span class="comment">#9 daemon prio=9 os_prio=2 tid=0x000000001c880000 nid=0x6498 waiting on condition</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;C2 CompilerThread1&quot;</span> <span class="comment">#8 daemon prio=9 os_prio=2 tid=0x000000001c87c000 nid=0x693c waiting on condition</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;C2 CompilerThread0&quot;</span> <span class="comment">#7 daemon prio=9 os_prio=2 tid=0x000000001c87b800 nid=0x5d00 waiting on condition</span></span><br><span class="line">[0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="string">&quot;Monitor Ctrl-Break&quot;</span> <span class="comment">#6 daemon prio=5 os_prio=0 tid=0x000000001c862000 nid=0x6034 runnable</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>注意：使用jps结合jstack命令可以分析线上生产环境的Java进程的异常信息。  </p>
<h3 id="线程的执行顺序是不确定的"><a href="#线程的执行顺序是不确定的" class="headerlink" title="线程的执行顺序是不确定的"></a>线程的执行顺序是不确定的</h3><p>调用Thread的start()方法启动线程时，线程的执行顺序是不确定的。也就是说，在同一个方法中，连续创建多个线程后，调用线程的start()方法的顺序并不能决定线程的执行顺序。</p>
<p>可以使用Thread类中的join()方法来确保线程的执行顺序。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1.start();</span><br><span class="line">//实际上让主线程等待子线程执行完成</span><br><span class="line">thread1.join();  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，调用子线程的join()方法，会阻塞main()方法的执行，当子线程执行完成后，main()方法会继续向下执行，启动第二个子线程，并执行子线程的业务逻辑，以此类推。  </p>
</blockquote>
<h2 id="两种异步模型与深度解析Future接口"><a href="#两种异步模型与深度解析Future接口" class="headerlink" title="两种异步模型与深度解析Future接口"></a>两种异步模型与深度解析Future接口</h2><h3 id="无返回结果的异步模型"><a href="#无返回结果的异步模型" class="headerlink" title="无返回结果的异步模型"></a>无返回结果的异步模型</h3><p>略  </p>
<h3 id="有返回结果的异步模型"><a href="#有返回结果的异步模型" class="headerlink" title="有返回结果的异步模型"></a>有返回结果的异步模型</h3><p>使用Future接口往往配合线程池来获取异步执行结果  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;测试Future获取异步结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<p>使用FutureTask类获取异步结果  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;测试FutureTask获取异步结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;测试FutureTask获取异步结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(futureTask);</span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure>

<p>可以看到使用Future接口或者FutureTask类来获取异步结果比使用回调接口获取异步结果简单多了。注意：实现异步的方式很多，这里只是用多线程举例。  </p>
<h3 id="深度解析Future接口"><a href="#深度解析Future接口" class="headerlink" title="深度解析Future接口"></a>深度解析Future接口</h3><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cancel(boolean)</span><br><span class="line">取消任务的执行，接收一个boolean类型的参数，成功取消任务，则返回true，否则返回false。当任务已经完成，已经结束或者因</span><br><span class="line">其他原因不能取消时，方法会返回false，表示任务取消失败。当任务未启动调用了此方法，并且结果返回true（取消成功），则当</span><br><span class="line">前任务不再运行。如果任务已经启动，会根据当前传递的boolean类型的参数来决定是否中断当前运行的线程来取消当前运行的任</span><br><span class="line">务  </span><br><span class="line"></span><br><span class="line">isCancelled()</span><br><span class="line">判断任务在完成之前是否被取消，如果在任务完成之前被取消，则返回true；否则，返回false。</span><br><span class="line">这里需要注意一个细节：只有任务未启动，或者在完成之前被取消，才会返回true，表示任务已经被成功取消。其他情况都会返回</span><br><span class="line">false。</span><br><span class="line"></span><br><span class="line">isDone()</span><br><span class="line">判断任务是否已经完成，如果任务正常结束、抛出异常退出、被取消，都会返回true，表示任务已经完成。</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line">当任务完成时，直接返回任务的结果数据；当任务未完成时，等待任务完成并返回任务的结果数据。</span><br><span class="line"></span><br><span class="line">get(long, TimeUnit)</span><br><span class="line">当任务完成时，直接返回任务的结果数据；当任务未完成时，等待任务完成，并设置了超时等待时间。在超时时间内任务完成，则</span><br><span class="line">返回结果；否则，抛出TimeoutException异常。</span><br></pre></td></tr></table></figure>

<h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW = 0;</span><br><span class="line">private static final int COMPLETING = 1;</span><br><span class="line">private static final int NORMAL = 2;</span><br><span class="line">private static final int EXCEPTIONAL = 3;</span><br><span class="line">private static final int CANCELLED = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED = 6;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">NEW -&gt; CANCELLED</span><br><span class="line">NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean isCancelled() &#123;</span><br><span class="line">	return state &gt;= CANCELLED;</span><br><span class="line">&#125; </span><br><span class="line">public boolean isDone() &#123;</span><br><span class="line">	return state != NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两方法中，都是通过判断任务的状态来判定任务是否已取消和已完成的。为啥会这样判断呢？再次查看FutureTask类中定义的状态常量发现，其常量的定义是有规律的，并不是随意定义的。其中，大于或者等于CANCELLED的常量为CANCELLED、INTERRUPTING和INTERRUPTED，这三个状态均可以表示线程已经被取消。当状态不等于NEW时，可以表示任务已经完成。</p>
<p>通过这里，大家可以学到一点：以后在编码过程中，要按照规律来定义自己使用的状态，尤其是涉及到业务中有频繁的状态变更的操作，有规律的状态可使业务处理变得事半功倍，这也是通过看别人的源码设计能够学到的，这里，建议大家还是多看别人写的优秀的开源框架的源码。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void done() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，done()方法是一个空的方法体，交由子类来实现具体的业务逻辑。当我们的具体业务中，需要在取消任务时，执行一些额外的业务逻辑，可以在子类中覆写done()方法的实现。</p>
<p>手动设置返回值和异常。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set()方法与setException()方法整体逻辑几乎一样，只是在设置任务状态时一个将状态设置为NORMAL，一个将状态设置为EXCEPTIONAL。  </p>
<h1 id="高并发系统实战"><a href="#高并发系统实战" class="headerlink" title="高并发系统实战"></a>高并发系统实战</h1><h2 id="高并发关键指标"><a href="#高并发关键指标" class="headerlink" title="高并发关键指标"></a>高并发关键指标</h2><p>QPS（一秒内处理多个请求，主要用来表示读请求，我们的系统可能大多是<strong>写请求</strong>）根据二八原则。80%的流量是在20%的时间段产生的。</p>
<p>例如每天有500w个请求，预估QPS&#x3D;（500w<em>0.8）&#x2F;（12(只算白天)*60*60*0.2）&#x3D;462，即当前系统每天QPS为462，当然为了保险起见预留20%也是可以的。*<em>一般还需要计算当天最高QPS，这样对系统的掌握了最强。</em></em></p>
<p>简单的算的话，系统最高QPS可以通过系统平均QPS的倍数计算出来，例如<strong>分析得出</strong>（怎么分析啊啊啊，只能说根据实践经验）最高QPS大概是平均QPS的2倍，则当前系统峰值QPS为924左右。</p>
<p>在预估出QPS后，机器数&#x3D;峰值QPS&#x2F;单台机器最高可承受的QPS，其中单台最高可承受的QPS可以通过压测来得出。</p>
<p>一个TPS可能包含多个QPS，例如访问一个页面会请求服务器3次，所以产生1个TPS，3个QPS。</p>
<h2 id="分布式的弊端"><a href="#分布式的弊端" class="headerlink" title="分布式的弊端"></a>分布式的弊端</h2><p>不仅仅是技术上的复杂度增加，而且也有可能会出现重复造轮子的情况。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>架构分层很重要，业务服务（面对应用功能），基础服务（面对可重用功能），系统服务（基础设施或中间件提供）</p>
<h3 id="微服务的问题"><a href="#微服务的问题" class="headerlink" title="微服务的问题"></a>微服务的问题</h3><ol>
<li>增加了复杂度</li>
<li>服务间的通信会变得复杂</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RESTful和RPC（远程过程调用）是两种不同的通信协议和设计风格，具有以下区别：</span><br><span class="line"></span><br><span class="line">1. 协议和传输方式：</span><br><span class="line">   - RESTful（Representational State Transfer）：基于HTTP协议，使用标准的HTTP方法（如GET、POST、PUT、DELETE）进行通信，并使用URL作为资源的唯一标识。</span><br><span class="line">   - RPC（Remote Procedure Call）：可以使用多种传输协议，如HTTP、TCP、UDP等，其关注的是通过远程过程调用来实现不同服务之间的通信。</span><br><span class="line"></span><br><span class="line">2. 接口风格：</span><br><span class="line">   - RESTful：采用资源导向的设计理念，将服务视为一组资源，通过URL对资源进行操作。使用HTTP方法来表示对资源的不同操作，如GET用于获取资源，POST用于创建资源，PUT用于更新资源，DELETE用于删除资源。通过不同的HTTP状态码来表示操作的结果。</span><br><span class="line">   - RPC：更加面向过程的风格，将远程服务看作是一个可调用的过程或函数，提供具体的方法调用和参数传递。</span><br><span class="line"></span><br><span class="line">3. 数据交互方式：</span><br><span class="line">   - RESTful：使用各种不同的数据格式进行交互，如JSON、XML等。可以通过HTTP的请求头中的Content-Type字段指定数据格式。</span><br><span class="line">   - RPC：通常使用二进制数据格式进行传输，从而减少数据的大小和网络传输的开销。</span><br><span class="line"></span><br><span class="line">4. 设计哲学和通信效率：</span><br><span class="line">   - RESTful：强调可伸缩性、可扩展性和松耦合。通过明确的URL和HTTP方法，使得服务端和客户端之间的接口更清晰可见。由于基于HTTP协议，通信效率比较低，但具有更好的可读性和可理解性。</span><br><span class="line">   - RPC：追求高效通信和低延迟。可以使用二进制传输协议，减少数据的大小和传输的开销，从而提高通信效率。</span><br><span class="line"></span><br><span class="line">总体而言，RESTful更加注重资源和状态的抽象，适用于构建面向资源的互联网应用，而RPC更加注重方法调用和传输效率，适用于构建分布式系统和服务之间的调用。具体选择RESTful还是RPC要根据具体的项目需求、场景和技术栈来进行评估和选择。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>微服务边界的划分增加了实现的复杂度</li>
</ol>
<p>微服务边界划分是微服务设计的难点，划分的好坏直接决定了整个微服务架构的好坏，会影响整个产品的推进进度：</p>
<ul>
<li>如果服务颗粒度分得过粗，则随着业务复杂度的上升，系统又会是一个个庞大的单体应用</li>
<li>如果过细，会出现数量很多的服务，增加运维和监控的成本，增加调用链的复杂度，影响系统性能</li>
<li>重新划分分组的工作量巨大且风险很高</li>
</ul>
<ol start="4">
<li>保持数据一致性非常复杂</li>
<li>对运维提出了更高的要求</li>
<li>建议采用敏捷开发模式而不是瀑布</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">微服务架构和敏捷开发模型有很好的契合度，可以提供更高的灵活性和快速的迭代开发。以下是为什么建议微服务架构采用敏捷开发模型而不是瀑布模型的几个原因：</span><br><span class="line"></span><br><span class="line">1. 快速迭代和部署：微服务架构的特点是将一个大型的应用系统拆分成多个小的、自治的服务。每个服务都可以独立开发、部署和扩展。而敏捷开发模型强调快速迭代和灵活的开发过程，能够更好地支持微服务的快速开发和部署需求。</span><br><span class="line"></span><br><span class="line">2. 灵活性和可变性：在微服务架构中，各个服务是相互独立的，并且可以使用不同的技术栈和编程语言来实现。这种灵活性要求开发团队能够快速适应需求的变化，并迅速调整服务。而敏捷开发模型强调适应变化和快速响应需求的能力，有助于团队在微服务架构中灵活地开发和调整服务。</span><br><span class="line"></span><br><span class="line">3. 高效的团队协作：微服务架构需要跨多个服务的团队协作开发，各个服务团队之间需要进行紧密的协调和交流。敏捷开发模型通过迭代开发、持续集成和快速交付，促进了团队成员之间的合作，提高了团队的协作效率。</span><br><span class="line"></span><br><span class="line">4. 分布式系统复杂性：微服务架构是一个分布式系统，涉及到多个服务之间的通信和协调。分布式系统的设计和开发相对复杂，需要更加灵活和敏捷的开发模型才能应对系统的复杂性。</span><br><span class="line"></span><br><span class="line">总结来说，微服务架构具有灵活性、快速迭代和团队协作的特点，而敏捷开发模型强调快速迭代、灵活性和协作能力，因此更适合微服务架构的开发。而传统的瀑布模型更适用于单体应用开发，无法满足微服务架构下快速迭代和团队协作的需求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">瀑布模型是一种传统的软件开发方法，其主要特点是按照线性顺序完成各个开发阶段，例如需求分析、设计、编码、测试、部署等。以下是瀑布模型的一些好处和适用场景：</span><br><span class="line"></span><br><span class="line">1. 清晰的阶段划分：瀑布模型将软件开发过程分为不同的阶段，每个阶段都有明确的输入和输出，使开发过程可控。这种划分可以更好地组织和调度开发项目，并提供清晰的开发计划。</span><br><span class="line"></span><br><span class="line">2. 文档重视和归档：瀑布模型强调详细的文档编写，包括需求文档、设计文档、测试文档等。这有助于记录项目的整个开发历程和结果，并在后续的维护和升级中提供参考。</span><br><span class="line"></span><br><span class="line">3. 适用于稳定需求：适用于那些需求变动较小且相对稳定的项目。瀑布模型基于事先完整的需求分析，开发过程中尽量避免大的变更，适合具有明确且稳定需求的项目。</span><br><span class="line"></span><br><span class="line">4. 简化团队协作：瀑布模型中的开发过程是线性的，各个阶段有明确的责任分工，团队成员可以更清晰地理解自己的职责，并且可以在每个阶段有明确的验收标准。</span><br><span class="line"></span><br><span class="line">适合采用瀑布模型的项目通常包括确定性较强、需求稳定、规模较小且较简单的项目，例如传统的软件产品开发、网站开发等。此外，对于要求强调文档记录和能够明确计划的项目，瀑布模型也相对适用。</span><br><span class="line"></span><br><span class="line">需要注意的是，随着软件开发的快速变化和需求的不断演化，瀑布模型在变化频繁的项目中可能不适用。敏捷开发模型和微服务架构更适合此类项目，可以更好地应对需求变更和快速迭代的需求。因此，在选择开发模型时，需要综合考虑项目的特点、需求变更频率和团队的工作方式。</span><br></pre></td></tr></table></figure>

<h2 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h2><p><strong>执行器框架（Executor Framework）将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable</strong>接口的对象和使用<strong>Executor</strong>对象，然后将<strong>Runnable</strong>对象发送给执行器。执行器再负责运行这些任务所需要的线程，包括线程的创建，线程的管理以及线程的结束。</p>
<p><strong>Java 7</strong>则又更进了一步，它包括了ExecutorService接口的另一种实现，用来解决特殊类型的问题，它就是<strong>Fork&#x2F;Join框架</strong>，有时也称<strong>分解&#x2F;合并框架</strong>。</p>
<p>将<strong>ForkJoinPool</strong>类看作一个特殊的 <strong>Executor</strong> 执行器类型。这个框架基于以下两种操作。</p>
<ul>
<li><strong>分解（Fork）</strong>操作：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务；</li>
<li><strong>合并（Join）</strong>操作：当一个主任务等待其创建的多个子任务的完成执行。</li>
</ul>
<p><strong>Fork&#x2F;Join框架和执行器框架（Executor Framework）主要的区别在于工作窃取算法（Work-Stealing Algorithm）</strong>。与执行器框架不同，使用Join操作让一个主任务等待它所创建的子任务的完成，执行这个任务的线程称之为<strong>工作者线程（Worker Thread）</strong>。工作者线程寻找其他仍未被执行的任务，然后开始执行。通过这种方式，这些线程在运行时拥有所有的优点，进而提升应用程序的性能。</p>
<p>为了达到这个目标，通过<strong>Fork&#x2F;Join框架</strong>执行的任务有以下限制。</p>
<ul>
<li>任务只能使用<strong>fork()和join()</strong> 操作当作同步机制。如果使用其他的同步机制，工作者线程就不能执行其他任务，当然这些任务是在同步操作里时。比如，如果在<strong>Fork&#x2F;Join 框架</strong>中将一个任务休眠，正在执行这个任务的工作者线程在休眠期内不能执行另一个任务。</li>
<li>任务不能执行I&#x2F;O操作，比如文件数据的读取与写入。</li>
<li>任务不能抛出非运行时异常（Checked Exception），必须在代码中处理掉这些异常。</li>
</ul>
<p><strong>Fork&#x2F;Join框架</strong>的核心是由下列两个类组成的。</p>
<ul>
<li><strong>ForkJoinPool：</strong>这个类实现了ExecutorService接口和工作窃取算法（Work-Stealing Algorithm）。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。</li>
<li><strong>ForkJoinTask：这个类是一个将在ForkJoinPool</strong>中执行的任务的基类。</li>
</ul>
<p><strong>Fork&#x2F;Join框架</strong>提供了在一个任务里执行<strong>fork()和join()操作的机制和控制任务状态的方法。通常，为了实现Fork&#x2F;Join</strong>任务，需要实现一个以下两个类之一的子类。</p>
<ul>
<li><strong>RecursiveAction：</strong>用于任务没有返回结果的场景。</li>
<li><strong>RecursiveTask：</strong>用于任务有返回结果的场景。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(任务很小）&#123;</span><br><span class="line">	直接计算得到结果</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	分拆成N个子任务</span><br><span class="line">	调用子任务的fork()进行计算</span><br><span class="line">	调用子任务的join()合并计算结果</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在Java中，ForkJoin框架与ThreadPool共存，并不是要替换ThreadPool其实，在Java 8中引入的并行流计算，内部就是采用的ForkJoinPool来实现的。例如，下面使用并行流实现打印数组元组的程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumArray</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">		numberList.parallelStream().forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin框架是从jdk1.7中引入的新特性,它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入指定的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。  </p>
<p>当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法向任务队列中再添加一个任务并在等待该任务完成之后再继续执行。而使用ForkJoinPool就能够解决这个问题，它就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。  </p>
<p>那么使用ThreadPoolExecutor或者ForkJoinPool，性能上会有什么差异呢？首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，很显然这是不可行的，也是很不合理的！！  </p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<ul>
<li><p>工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争。  </p>
</li>
<li><p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗更多的系统资源，比如创建多个线程和多个双端<br>队列。  </p>
</li>
<li><p>Fork&#x2F;Join框架局限性：对于Fork&#x2F;Join框架而言，当一个任务正在等待它使用Join操作创建的子任务结束时，执行这个任务的工作线程查找其他未被执行的任务，并开始执行这些未被执行的任务，通过这种方式，线程充分利用它们的运行时间来提高应用程序的性能。为了实现这个目标，Fork&#x2F;Join框架执行的任务有一些局限性。</p>
</li>
</ul>
<p>ForkJoinPool 框架中涉及的主要类如下所示。</p>
<ol>
<li><p>ForkJoinPool类<br>实现了ForkJoin框架中的线程池，由类图可以看出，ForkJoinPool类实现了线程池的Executor接口。</p>
<p>其中，可以使用Executors.newWorkStealPool()方法创建ForkJoinPool。  </p>
<p>ForkJoinPool中提供了如下提交任务的方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span></span><br><span class="line"><span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task)</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForkJoinWorkerThread类<br>   实现ForkJoin框架中的线程。</p>
</li>
<li><p>ForkJoinTask类</p>
<p>  ForkJoinTask封装了数据及其相应的计算，并且支持细粒度的数据并行。ForkJoinTask比线程要轻量，ForkJoinPool中少量工作线程能够运行大量的ForkJoinTask。<br>  ForkJoinTask类中主要包括两个方法fork()和join()，分别实现任务的分拆与合并。fork()方法类似于Thread.start()，但是它并不立即执行任务，而是将任务放入工作队列中。跟Thread.join()方法不同，ForkJoinTask的join()方法并不简单的阻塞线程，而是利用工作线程运行其他任务，当一个工作线程中调用join()，它将处理其他任务，直到注意到目标子任务已经完成。 </p>
<p>  <img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230729213021439.png" alt="image-20230729213021439"></p>
</li>
</ol>
<p>ForkJoinTask有3个子类：  </p>
<ul>
<li><p>RecursiveAction：无返回值的任务。无返回结果的ForkJoinTask实现Runnable。  </p>
</li>
<li><p>RecursiveTask：有返回值的任务。有返回结果的ForkJoinTask实现Callable。  </p>
</li>
<li><p>CountedCompleter：完成任务后将触发其他任务。 在任务完成执行后会触发执行一个自定义的钩子函数。</p>
</li>
</ul>
<h3 id="ForkJoin示例程序"><a href="#ForkJoin示例程序" class="headerlink" title="ForkJoin示例程序"></a>ForkJoin示例程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.binghe.concurrency.example.aqs;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTaskExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ForkJoinTaskExample</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.start = start;</span><br><span class="line">    	<span class="built_in">this</span>.end = end;</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= threshold;</span><br><span class="line">		<span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">				sum += i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">			<span class="type">ForkJoinTaskExample</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(start, middle);</span><br><span class="line">			<span class="type">ForkJoinTaskExample</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">			<span class="comment">// 执行子任务</span></span><br><span class="line">			leftTask.fork();</span><br><span class="line">			rightTask.fork();</span><br><span class="line">			<span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join();</span><br><span class="line">			<span class="comment">// 合并子任务</span></span><br><span class="line">			sum = leftResult + rightResult;</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ForkJoinPool</span> <span class="variable">forkjoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">		<span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">		<span class="type">ForkJoinTaskExample</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinTaskExample</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">		<span class="comment">//执行一个任务</span></span><br><span class="line">		Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			log.info(<span class="string">&quot;result:&#123;&#125;&quot;</span>, result.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="java-concurrency-in-practice"><a href="#java-concurrency-in-practice" class="headerlink" title="java-concurrency-in-practice"></a>java-concurrency-in-practice</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>Indeed, developing, testing and debugging multithreaded programs can be extremely difficult because concurrency bugs do not manifest themselves predictably. And when they do surface, it is often at the worst possible time—in production, under heavy load.  </p>
<blockquote>
<p>测试和debug往往很难发现并发问题，他们总在最坏的时候出现——生产上，高负载下</p>
</blockquote>
<p>One of the challenges of developing concurrent programs in Java is the mismatch between the concurrency features offered by the platform and how developers need to think about concurrency in their programs. The language provides low-level mechanisms such as synchronization and condition waits, but these mechanisms must be used consistently to implement application-level protocols or policies. Without such policies, it is all too easy to create programs that compile and appear to work but are nevertheless broken. Many otherwise excellent books on concurrency fall short of their goal by focusing excessively on low-level mechanisms and APIs rather than design-level policies and patterns.  </p>
<blockquote>
<p>并发机制的底层机制与实际业务的复杂度是并发编程的难点</p>
</blockquote>
<h2 id="How-to-use-this-book"><a href="#How-to-use-this-book" class="headerlink" title="How to use this book"></a>How to use this book</h2><p>it offers practical design rules to assist developers in the difficult process of creating safe and performant concurrent classes.   </p>
<blockquote>
<p>本书不会介绍API，而是介绍设计理念</p>
</blockquote>
<p>基础部分（很重要）Chapters 2 (Thread Safety) and 3 (Sharing Objects) form the foundation for the book.   </p>
<p>构建并发应用Chapter 7 (Cancellation and Shutdown) deals with techniques for convincing tasks and threads to terminate before they would normally do so; how programs deal with cancellation and shutdown is often one of the factors that separates truly robust concurrent applications from those that merely work.  </p>
<blockquote>
<p>如何实现取消和关闭等操作，往往是区别好的并发和坏的并发的关键</p>
</blockquote>
<p><strong>完整代码示例：<a target="_blank" rel="noopener" href="http://www.javaconcurrencyinpractice.com/">http://www.javaconcurrencyinpractice.com</a></strong>  </p>
<h2 id="线程的风险"><a href="#线程的风险" class="headerlink" title="线程的风险"></a>线程的风险</h2><p>The problem with UnsafeSequence is that with some unlucky timing, two threads could call getNext and receive the same value. Figure 1.1 shows how this can happen. The increment notation, someVariable++, may appear to be a single operation, but is in fact three separate operations: <strong>read the value, add one to it, and write out the new value</strong>. Since operations in multiple threads may be arbitrarily interleaved by the runtime, it is possible for two threads to read the value at the same time, both see the same value, and then both add one to it. The result is that the same sequence number is returned from multiple calls in different threads  </p>
<p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230812142948672.png" alt="image-20230812142948672"></p>
<p>Like most concurrency bugs, bugs that cause liveness failures can be elusive because they depend on the relative timing of events in different threads, and therefore do not always manifest themselves in development or testing  </p>
<blockquote>
<p>死锁问题同样难以在开发和测试中发现。</p>
</blockquote>
<p>In well designed concurrent applications the use of threads is a net performance gain, but threads nevertheless carry some degree of runtime overhead. Context switches—when the scheduler suspends the active thread temporarily so another thread can run—are more frequent in applications with many threads, and have significant costs: saving and restoring execution context, loss of locality, and CPU time spent scheduling threads instead of running them.   When threads share data, they must use synchronization mechanisms that can inhibit compiler optimizations, flush or invalidate memory caches, and create synchronization traffic on the shared memory bus. All these factors introduce additional performance costs;   </p>
<blockquote>
<p>多线程本身就会带来一些额外开销：保存和恢复线程上下文，局部性的损失、CPU额外的线程调度耗时而不是执行耗时，以及同步机制（会导致禁止编译器优化，使线程缓存失效，增加内存总线的同步流量）</p>
</blockquote>
<blockquote>
<p>在多线程编程中，”loss of locality”（局部性的损失）指的是由于多个线程同时访问不同的数据或资源，导致数据访问的局部性减弱的情况。</p>
<p>当多个线程同时访问不同的数据或资源时，这些数据或资源可能被散布在内存的不同位置上。而处理器(CPU)访问内存的速度远远低于访问内部缓存的速度。因此，当线程在不同的内存位置上并发地访问数据时，频繁地从内存中加载数据到处理器缓存或进行写回动作，会导致较低的缓存命中率和较高的缓存争用，从而降低程序的性能。</p>
</blockquote>
<p>When concurrency is introduced into an application by a framework, it is usually impossible to restrict the concurrency-awareness to the framework code, because frameworks by their nature make callbacks to application components that in turn access application state. Similarly, the need for thread safety does not end with the components called by the framework—it extends to all code paths that access the program state accessed by those components. Thus, the need for thread safety is contagious.  </p>
<p>Frameworks introduce concurrency into applications by calling application components from framework threads. Components invariably access<br>application state, thus requiring that all code paths accessing that state be thread-safe.  </p>
<blockquote>
<p>框架引发的并发问题具有传染性</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Writing thread-safe code is, at its core, about managing access to state, and in particular to shared, mutable state  </p>
<p>The primary mechanism for synchronization in Java is the synchronized keyword, which provides exclusive locking, but the term “synchronization” also includes the use of volatile variables, explicit locks, and atomic variables.  </p>
<blockquote>
<p>主流的四种锁或原子操作，synchronized 、volatile 、lock、atomic </p>
</blockquote>
<p>If multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to<br>fix it:</p>
<p>• Don’t share the state variable across threads;</p>
<p>• Make the state variable immutable; or</p>
<p>• Use synchronization whenever accessing the state variable.  </p>
<blockquote>
<p>不跨线程共享变量、将变量设为不可变，或对于任何用到状态值的地方使用同步机制</p>
</blockquote>
<p>Sometimes abstraction and encapsulation are at odds with performance—although not nearly as often as many developers believe—but it is always a good practice first to make your code right, and then make it fast. Even then, pursue optimization only if your performance measurements and requirements tell you that you must, and if those same measurements tell you that your optimizations actually made a difference under realistic conditions.</p>
<blockquote>
<p>非必要不优化，先写对的，再写快的，有时候对于一些不常执行的代码一些小的性能提升会带来一些bug，先保证对再说</p>
</blockquote>
<h3 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h3><p>a class is thread-safe when it continues to behave correctly when accessed from multiple threads.  </p>
<blockquote>
<p>不太正式的定义</p>
</blockquote>
<p>A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of<br>those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.  </p>
<blockquote>
<p>这个定义不错，线程安全的类是不需要额外的同步或者协作机制的…所以我们编写的大部分类都是线程不安全的</p>
</blockquote>
<p>If an object is correctly implemented, no sequence of operations—calls to public methods and reads or writes of public fields—should be able to violate any of its invariants or postconditions. No set of operations performed sequentially or concurrently on instances of a thread-safe class can cause an instance to be in an invalid state.  </p>
<blockquote>
<p>只要正确实现了一个类，任何函数调用或者读写public值都不会违背不可变性或后置条件，串行或者并发操作不会让类处于不可用状态。</p>
</blockquote>
<p>Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.  </p>
<p>Stateless objects are always thread-safe.  </p>
<p>The fact that most servlets can be implemented with no state greatly reduces the burden of making servlets thread-safe. It is only when servlets want to remember things from one request to another that the thread safety requirement becomes an issue.  </p>
<blockquote>
<p>事实上，大多数servlet都可以在没有状态的情况下实现，这大大减轻了使servlet线程安全的负担。只有当servlet希望记住从一个请求到另一个请求的内容时，线程安全要求才会成为问题。</p>
</blockquote>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="竞态状态"><a href="#竞态状态" class="headerlink" title="竞态状态"></a>竞态状态</h4><p>基于一种可能失效的观察结果来做出判断或者执行某个计算</p>
<h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><p>Where practical, use existing thread-safe objects, like AtomicLong, to manage your class’s state. It is simpler to reason about the possible<br>states and state transitions for existing thread-safe objects than it is for arbitrary state variables, and this makes it easier to maintain and verify<br>thread safety.  </p>
<blockquote>
<p>在实际情况下，尽可能使用现有的线程安全对象，如AtomicLong，来管理类的状态。与任意状态变量相比，推断现有线程安全对象的可能状态和状态转换更简单，这使得维护和验证线程安全性更容易</p>
</blockquote>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><blockquote>
<p>要保持状态地一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
</blockquote>
<h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><p>A synchronized method is a shorthand for a synchronized block that spans an entire method body, and whose lock is the object on which the method is being invoked. (Static synchronized methods use the Class object for the lock.)  </p>
<blockquote>
<p>synchronized（）锁的是调用对象，静态synchronized方法锁的是class</p>
</blockquote>
<p>The machinery of synchronization makes it easy to restore thread safety to the factoring servlet. Listing 2.6 makes the service method synchronized, so only one thread may enter service at a time. SynchronizedFactorizer is now thread-safe; however, this approach is fairly extreme, since it inhibits multiple clients from using the factoring servlet simultaneously at all—resulting in unacceptably poor responsiveness. This problem—which is a performance problem, not a thread safety problem  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">		<span class="keyword">if</span> (i.equals(lastNumber))</span><br><span class="line">			encodeIntoResponse(resp, lastFactors);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			BigInteger[] factors = factor(i);</span><br><span class="line">			lastNumber = i;</span><br><span class="line">			lastFactors = factors;</span><br><span class="line">			encodeIntoResponse(resp, factors);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reentrancy-重入锁"><a href="#Reentrancy-重入锁" class="headerlink" title="Reentrancy(重入锁)"></a>Reentrancy(重入锁)</h4><p>When a thread requests a lock that is already held by another thread, the requesting thread blocks. But because intrinsic locks are reentrant, if a thread tries to acquire a lock that it already holds, the request succeeds. Reentrancy means that locks are acquired on a per-thread rather than per-invocation basis.7 Reentrancy is implemented by associating with each lock an acquisition count and an owning thread. When the count is zero, the lock is considered unheld. When a thread acquires a previously unheld lock, the JVM records the owner and sets the acquisition count to one. If that same thread acquires the lock again, the count  </p>
<blockquote>
<p>如果锁已经由一个线程持有，那么该线程一直请求这个锁都会成功</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingWidget</span> <span class="keyword">extends</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(toString() + <span class="string">&quot;: calling doSomething&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Guarding-state-with-locks（用锁来保护状态）"><a href="#Guarding-state-with-locks（用锁来保护状态）" class="headerlink" title="Guarding state with locks（用锁来保护状态）"></a>Guarding state with locks（用锁来保护状态）</h3><p><strong>如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步，而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。</strong></p>
<p>一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此。</p>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。</p>
<blockquote>
<p>一处是synchronized，处处都要是synchronized</p>
</blockquote>
<p>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。</p>
<p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。</p>
<blockquote>
<p>我理解就是把涉及到并发的共享变量封装在某个类里，然后所有访问共享变量的方法都需要获取这个类的锁，从而避免直接引用导致线程安全问题。</p>
</blockquote>
<p>当类的不变性条件涉及多个状态变量时，那么还有另外一个需求：<strong>在不变性条件中的每个变量都必须由同一个锁来保护</strong>，因此可以在单个原子操作中访问或更新这些变量，从而确保不变性条件不被破坏。</p>
<h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><p>幸运的是，通过缩小同步代码块的作用范围，可以做到线程安全又有一定的性能，要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中，应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中其他线程可以访问共享变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger lastNumber;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">long</span> hits;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">long</span> cacheHits;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getHits</span><span class="params">()</span> &#123; <span class="keyword">return</span> hits; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">double</span> <span class="title function_">getCacheHitRatio</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">double</span>) cacheHits / (<span class="type">double</span>) hits;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">		BigInteger[] factors = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			++hits;</span><br><span class="line">			<span class="keyword">if</span> (i.equals(lastNumber)) &#123;</span><br><span class="line">				++cacheHits;</span><br><span class="line">				factors = lastFactors.clone();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (factors == <span class="literal">null</span>) &#123;</span><br><span class="line">			factors = factor(i);</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">				lastNumber = i;</span><br><span class="line">				lastFactors = factors.clone();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		encodeIntoResponse(resp, factors);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CachedFactorizer no longer uses AtomicLong for the hit counter, instead reverting to using a long field. It would be safe to use AtomicLong here, but there is less benefit than there was in CountingFactorizer. Atomic variables are useful for effecting atomic operations on a single variable, but since we are already using synchronized blocks to construct atomic operations, using two different synchronization mechanisms would be confusing and would offer no performance or safety benefit.  </p>
<p>对于单个变量上实现原子操作来说，原子变量（atomic类）是很有用的，但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处，因此在这里不使用原子变量。</p>
<p>在获取和释放锁等操作上都需要一定的开销，因此如果将同步代码块分解得过细通常不好（比如将++hints分解到它自己得同步代码块中）</p>
<p>要判断同步代码块得合理大小，需要在各种设计需求之间进行权衡，包括安全性（必须满足）、简单性和性能。有时候简单性和性能之间会发生冲突，但通常能够找到某种合理得平衡。</p>
<p>There is frequently a tension between simplicity and performance. When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.  </p>
<p><strong>当使用锁时，应该清楚代码块实现的功能，以及执行该代码块时是否需要很长的时间，无论是计算密集的操作还是执行某个可能阻塞的操作，如果持有锁的时间过长，那么就会带来活跃性或性能问题。</strong></p>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>We have seen how synchronized blocks and methods can ensure that operations execute atomically, but it is a common misconception that synchronized is only about atomicity or demarcating “critical sections”. Synchronization also has another significant, and subtle, aspect: memory visibility. We want not only to prevent one thread from modifying the state of an object when another is using it, but also to ensure that when a thread modifies the state of an object, other threads can actually see the changes that were made. But without synchronization, this may not happen. You can ensure that objects are published safely either by using explicit synchronization or by taking advantage of the synchronization built into library classes.   </p>
<blockquote>
<p>我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
</blockquote>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoVisibility</span> &#123;	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!ready)</span><br><span class="line">				Thread.<span class="keyword">yield</span>();</span><br><span class="line">			System.out.println(number);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">		number = <span class="number">42</span>;</span><br><span class="line">		ready = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoVisibility could loop forever because the value of ready might never become visible to the reader thread. Even more strangely, NoVisibility could print zero because the write to ready might be made visible to the reader thread before the write to number, a phenomenon known as reordering.   </p>
<blockquote>
<p>有可能ready的值的变化永远不会被ReaderThread知晓（虽然我没复现，反正意思就是static也不能保证可见性）…更奇怪的是（有可能），由于重排序，会输出0，因为ready的变化被知晓但number的变化没有被知晓。</p>
</blockquote>
<p>Fortunately, there’s an easy way to avoid these complex issues: always use the proper synchronization whenever data is shared across threads.  </p>
<h4 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutableInteger</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MutableInteger不是线程安全的，因为get和set都是在没有同步的情况下访问value的。如果某个线程调用了set那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。</p>
<blockquote>
<p>很多地方我们都是这么用的，所以一定要确保这些类不会被多个线程访问</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedInteger</span> &#123;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Nonatomic-64-bit-operations（非原子的64位操作）"><a href="#Nonatomic-64-bit-operations（非原子的64位操作）" class="headerlink" title="Nonatomic 64-bit operations（非原子的64位操作）"></a>Nonatomic 64-bit operations（非原子的64位操作）</h4><p>Out-of-thin-air safety applies to all variables, with one exception: 64-bit numeric variables (double and long) that are not declared volatile (see Section<br>3.1.4). The Java Memory Model requires fetch and store operations to be atomic, but for nonvolatile long and double variables, the JVM is permitted to treat a 64-bit read or write as two separate 32-bit operations. If the reads and writes occur in different threads, it is therefore possible to read a nonvolatile long and get back the high 32 bits of one value and the low 32 bits of another.3 Thus, even if you don’t care about stale values, it is not safe to use shared mutable long and double variables in multithreaded programs unless they are declared volatile or guarded by a lock.  </p>
<blockquote>
<p>63位变量（long或者double）如果不采用同步机制有可能会读到不同线程的高32位和低32位。（以前的32位jdk和操作系统）</p>
<p>在一般情况下，64位JDK和操作系统上的JVM会直接进行64位的读写操作，以提高性能和效率</p>
</blockquote>
<h4 id="加锁和可见性"><a href="#加锁和可见性" class="headerlink" title="加锁和可见性"></a>加锁和可见性</h4><p>When thread A executes a synchronized block, and subsequently thread B enters a synchronized block guarded by the same lock, the values of variables that were visible to A prior to releasing the lock are guaranteed to be visible to B upon acquiring the  lock. In other words, everything A did in or prior to a synchronized block is visible to B when it executes a synchronized block guarded by the same lock. Without synchronization, there is no such guarantee.  </p>
<p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230822165504379.png" alt="image-20230822165504379"></p>
<blockquote>
<p>有了同步块（同一个锁），后一个线程就能看到前一个线程在同步块内所有的数据变更</p>
</blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h4 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h4><p>当把变量声明位volatile后，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序，volatile变量不会被缓存在寄存器或者其他对处理器不可见的地方，<strong>因此在读取volatile变量时总会返回最新写入的值</strong>。</p>
<blockquote>
<p>相反的，如果不是volatile的则有可能读的是线程中已读的值，但是写入的时候还是会覆盖彼此的值</p>
</blockquote>
<p>可以将他们的行为想象成SynchronizedInteger的类似行为，并将volatile变量的读操作和写操作分别替换为get方法和set方法。然而在访问volatile变量时并不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedInteger</span> &#123;</span><br><span class="line">	<span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; 	<span class="keyword">return</span> value; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So from a memory visibility perspective, writing a volatile variable is like exiting a synchronized block and reading a volatile variable is like entering a synchronized block.   However, we do not recommend relying too heavily on volatile variables for visibility; code that relies on volatile variables for visibility of arbitrary state is more fragile and harder to understand than code that uses locking  </p>
<blockquote>
<p>从内存可见性角度看，写volatile相当于退出synchronized块，读相当于进入synchronized块，然而并不建议过度依赖volatile变量，通常比使用锁的代码更加脆弱也更加难以理解</p>
</blockquote>
<p>Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when veryfing correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event (such as initialization or shutdown) has occurred.  </p>
<p>below illustrates a typical use of volatile variables: checking a status flagto determine when to exit a loop. In this example, our anthropomorphized thread is trying to get to sleep by the time-honored method of counting sheep. For this example to work, the asleep flag must be volatile. Otherwise, the thread might not notice when asleep has been set by another thread.6 We could instead have  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!asleep)</span><br><span class="line">countSomeSheep();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反正就是少用volatile，所以yw程序里的detectcompleted应该是volatile的，但不应该用于计数…详见下面的分析。或者直接用atomicBoolean</p>
</blockquote>
<p>volatile变量很方便但也存在一些局限性，volatile变量通常用作某个操作完成，发生中断或者状态的标志，尽量volatile变量也可以用作表示其他的状态信息但在使用时要非常小心，例如volatile的语义不足以确保递增操作的原子性，除非能确保只有一个线程对变量执行写操作，</p>
<p>Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.</p>
<p>You can use volatile variables only when all the following criteria are met:</p>
<p>• Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;</p>
<p>• The variable does not participate in invariants with other state variables;</p>
<p>• Locking is not required for any other reason while the variable is being accessed.  </p>
<blockquote>
<p>锁能保证可见性和原子性，但volatile只能保证可见性。只有满足以下几个条件时volatile变量才可以被使用</p>
<ul>
<li>写入并不依赖当前值，或者你可以保证只有一个线程更新这个值</li>
<li>变量不会参与其他状态变量的不变性</li>
<li>当变量被读时没有任何理由加锁</li>
</ul>
</blockquote>
<h3 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h3><p>This is a compelling reason to use encapsulation: it makes it practical to analyze programs for correctness and harder to violate design constraints accidentally.  </p>
<blockquote>
<p>这正是使用封装的原因：封装使得对程序的正确性分析变得可能，并使得无意中破坏涉及约束条件变得更难——我们的数据源不应该直接暴露给外部而是应该封装起来，比如网管的缓存静态类</p>
</blockquote>
<p>If someone steals your password and posts it on the alt.free-passwords newsgroup, that information has escaped: whether or not someone has (yet) used those credentials to create mischief, your account has still been compromised. Publishing a reference poses the same sort of risk.    </p>
<h4 id="安全的对象构造过程"><a href="#安全的对象构造过程" class="headerlink" title="安全的对象构造过程"></a>安全的对象构造过程</h4><p>不要在构造器里使this溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">		source.registerListener(</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">					doSomething(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的使this溢出的错误就是：从构造器启动了一个线程。当dui想在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程可以看见它，在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。在构造函数中调用一个可改写的实例方法时（既不是private也不是final）同样会导致this引用在构造过程中逸出。</p>
<p>如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeListener</span><span class="params">()</span> &#123;</span><br><span class="line">        listener = <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">        	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">        		doSomething(e);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title function_">newInstance</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        <span class="type">SafeListener</span> <span class="variable">safe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeListener</span>();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，只有当构造函数返回时，this引用才应该从线程中逸出。像这里应该直接调用newInstance方法</p>
<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭，是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<p>比如常见应用是JDBC的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。由于大多数请求都是由单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此这种连接管理模式再处理请求时隐含地将Connection对象封闭再线程中。</p>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><p>维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值得对象关联起来。</p>
<p>假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享全局变量转换为threadlocal对象，可以维持线程安全性。</p>
<p>开发人员经常滥用Threadlocal，例如将所有全局变量都作为threadlocal对象，或者作为一种“隐藏”方法参数的手段。threadlocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>虽然在java语言规范和java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍是可变的，因为在final类型的域中可以保存对可变对象的引用。</p>
<blockquote>
<p>since final fields can hold references to mutable objects.  </p>
</blockquote>
<p>当对象满足以下条件时才是不可变的：</p>
<ul>
<li>对象创建以后其状态不能修改</li>
<li>对象的所有域都是final的（从技术上说，不可变对象并不需要将其所有的域都声明为final类型，例如String就是这种情况）</li>
<li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreeStooges</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreeStooges</span><span class="params">()</span> &#123;</span><br><span class="line">        stooges.add(<span class="string">&quot;Moe&quot;</span>);</span><br><span class="line">        stooges.add(<span class="string">&quot;Larry&quot;</span>);</span><br><span class="line">        stooges.add(<span class="string">&quot;Curly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStooge</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While the Set that stores the names is mutable, the design of ThreeStooges makes it impossible to modify that Set after construction. The stooges reference is final, so all object state is reached through a final field.   </p>
<blockquote>
<p>stooges的内容可变，但是引用不可变</p>
</blockquote>
<h4 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h4><p>It is the use of final fields that makes possible the guarantee of initialization safety (see Section <strong>3.5.2</strong>) that lets immutable objects be freely accessed and shared without synchronization.  </p>
<blockquote>
<p>但是实验表明，就算将field设置为final在构造器里也会出现并发问题，这个问题在看了3.5.2之后再看看</p>
</blockquote>
<p>除非需要更高的可见性，否则应将所有的field都声明为private，除非需要某个field是可变的，否则应将其声明为final域</p>
<p>Race conditions in accessing or updating multiple related variables can be eliminated by using an immutable object to hold all the variables. With a mutable  holder object, you would have to use locking to ensure atomicity; with an immutable one, once a thread acquires a reference to it, it need never worry about another thread modifying its state. <strong>If the variables are to be updated, a new holder object is created</strong>, but any threads working with the previous holder still see it in a consistent state.  </p>
<blockquote>
<p>我的理解是，代码要修改这个 immutable object时，除了重新new一个并无它法（值的改变被封装在了构造函数里而不是各自单独的函数），再加上是volatile的，也保证了可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneValueCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OneValueCache</span><span class="params">(BigInteger i,</span></span><br><span class="line"><span class="params">        BigInteger[] factors)</span> &#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="literal">null</span> || !lastNumber.equals(i))</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">OneValueCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OneValueCache</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="literal">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">OneValueCache</span>(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><h4 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe publication</span></span><br><span class="line"><span class="keyword">public</span> Holder holder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">	holder = <span class="keyword">new</span> <span class="title class_">Holder</span>(<span class="number">42</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assertSanity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在未正确发布的对象中存在两个问题，首先，除了发布对象的线程外，其它线程可以看到的Holder是一个失效值，因此将看到一个空引用或者之前的旧值。然而更糟糕的情况是，线程看到Holder引用的值是最新的，但Holder状态的值却是失效的</p>
<p>While it may seem that field values set in a constructor are the first values written to those fields and therefore that there are no “older” values to see as stale values, the Object constructor first writes the default values to all fields before subclass constructors run. It is therefore possible to see the<br>default value for a field as a stale value.  </p>
<blockquote>
<p><strong>这里存在疑问——我感觉作者是想表达在Holder被构造器构造期间被读取，这个时候n的值是JVM赋予的默认值0，但是此时构造还没完成应该不会返回对象引用，其他线程是怎么可能读到这个最新的对象引用的</strong></p>
</blockquote>
<p>有可能的是，某个线程在第一次读取域时得到失效的值，而再次读取这个域时会得到一个更新值。</p>
<blockquote>
<p>补充知识：</p>
<p><strong>问题：</strong> 在不使用volatile关键字的情况下，有哪些情况会导致线程的工作内存失效，然后必须重新去读取主存的共享变量？</p>
<p>1、线程中释放锁时</p>
<p>2、线程切换时</p>
<p>3、CPU有空闲时间时（比如线程休眠时）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		count--;</span><br><span class="line">        <span class="comment">//下面的语句涉及到IO操作，所以会导致线程切换，从而重新去主存读取count值</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Test01</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test01</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(t).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread-0 ount &#x3D; 7<br>        Thread-3 ount &#x3D; 5<br>        Thread-4 ount &#x3D; 6<br>        Thread-1 ount &#x3D; 7<br>        Thread-2 ount &#x3D; 7</p>
</blockquote>
<p>这个结果不是固定的。造成这个问题的原因是，同时开启了五个线程，五个线程把主存中的值拷贝到线程的工作内存中，然后执行 run() 方法在该方法中对count进行减一。遇到 System.out.println语句后引起线程切换。导致了将工作内存中的count刷写回主存，然后执行 System.out.println时重新从主存中读取值。如果对run方法加锁即可解决该问题</p>
<h4 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h4><p>Immutable objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.  </p>
<p>This guarantee extends to the values of all final fields of properly constructed objects; final fields can be safely accessed without additional synchronization. However, if final fields refer to mutable objects, synchronization is still required to access the state of the objects they refer to.  </p>
<blockquote>
<p>所以一种有效的共享变量的方式是将共享变量里的field设置为final并且只能在构造器里对field进行赋值，不不不不，还是有问题，如果整个引用（即被重新构造的话）那么其他线程看到的也会是失效的引用</p>
<p>所以我理解这里的共享是指对象本身就是final的，一旦被初始化后就不允许重新构造了。</p>
</blockquote>
<h4 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h4><p>要安全地发布一个对象，对象地引用以及对象地状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li><p>在静态初始化函数中初始化一个对象引用（Initializing an object reference from a static initializer;  ）</p>
</li>
<li><p>将对象的引用保存到volatile类型的域或者AtomicReference对象中</p>
</li>
<li><p>将对象的引用保存到某个正确构造对象的final类型域中（Storing a reference to it into a final field of a properly constructed<br>object ）</p>
</li>
<li><p>将对象的引用保存到一个由锁保护的域中</p>
</li>
</ul>
<p>The internal synchronization in thread-safe collections means that placing an object in a thread-safe collection, such as a <strong>Vector</strong> or <strong>synchronizedList</strong>, fulfills the last of these requirements.   </p>
<blockquote>
<p>线程安全的容器类满足最后一个条件</p>
</blockquote>
<ul>
<li>Placing a key or value in a <strong>Hashtable</strong>, <strong>synchronizedMap</strong>, or <strong>ConcurrentMap</strong> safely publishes it to any thread that retrieves it from the Map (whether directly or via an iterator);</li>
<li>Placing an element in a <strong>Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, or synchronizedSet</strong> safely publishes it to<br>any thread that retrieves it from the collection;</li>
<li>Placing an element on a <strong>BlockingQueue or a ConcurrentLinkedQueue</strong> safely publishes it to any thread that retrieves it from the queue.</li>
</ul>
<p>Other handoff mechanisms in the class library (such as Future and Exchanger) also constitute safe publication; we will identify these as providing safe publication as they are introduced.  </p>
<p>Using a static initializer is often the easiest and safest way to publish objects that can be statically constructed:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>(<span class="number">42</span>);  </span><br></pre></td></tr></table></figure>

<p>如果要发布静态共享变量的话，直接在class里就将静态变量holder进行了初始化是比较好的方法，由JVM在类的初始化阶段执行，由于JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<h4 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h4><p>The safe publication mechanisms all guarantee that the as-published state of an object is visible to all accessing threads as soon as the reference to it is visible, and if that state is not going to be changed again, this is sufficient to ensure that any access is safe.  </p>
<blockquote>
<p>安全发布机制能确保当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的</p>
</blockquote>
<p>For example, Date is mutable, but if you use it as if it were immutable, you may be able to eliminate the locking that would otherwise be required when sharing a Date across threads. Suppose you want to maintain a Map storing the last login time of each user:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; lastLogin = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Date&gt;());</span><br></pre></td></tr></table></figure>

<p>If the Date values are not modified after they are placed in the Map, then the synchronization in the synchronizedMap implementation is sufficient to publish the Date values safely, and no additional synchronization is needed when accessing them.  </p>
<blockquote>
<p>注意这里还是用了synchronizedMap，但是Date本身不需要再使用同步机制</p>
</blockquote>
<h4 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h4><ul>
<li>Immutable objects can be published through any mechanism;</li>
<li>Effectively immutable objects must be safely published;</li>
<li>Mutable objects must be safely published, and must be either threadsafe or guarded by a lock.</li>
</ul>
<h4 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h4><p>When you publish an object, you should document how the object can be accessed.  </p>
<p>The most useful policies for using and sharing objects in a concurrent program are:</p>
<ul>
<li>Thread-confined. A thread-confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.</li>
<li>Shared read-only. A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.</li>
<li>Shared thread-safe. A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public<br>interface without further synchronization.</li>
<li>Guarded. A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and published objects that are known to be guarded by a specific lock.</li>
</ul>
<blockquote>
<p>最后两条：</p>
<p>线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</p>
<p>保护对象。被保护的对下个只能通过持有特定的锁来访问，保护对象包括封装在其它线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
</blockquote>
<h2 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h2><h3 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h3><p>在设计线程安全的类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>Identify the variables that form the object’s state;（找出构成对象状态的所有变量）</li>
<li>Identify the invariants that constrain the state variables;（找出约束状态变量的不变性条件）</li>
<li>Establish a policy for managing concurrent access to the object’s state（建立对象状态的并发访问管理策略）</li>
</ul>
<p>An object’s state starts with its fields. If they are all of primitive type, the fields comprise the entire state.   </p>
<blockquote>
<p>如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。</p>
</blockquote>
<p>If the object has fields that are references to other objects, its state will encompass fields from the referenced objects as well. For example, the state of a LinkedList includes the state of all the link node objects belonging to the list.  </p>
<p>如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域，例如LinkList的状态就包括该链表中所有节点对象的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == Long.MAX_VALUE)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;counter overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有synchronized，那么在多个线程都进行increment修改时就会导致并发问题，当然如果只有一个线程进行修改，那么synchronized也可以不加</p>
</blockquote>
<h4 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h4><p>Constraints placed on states or state transitions by invariants and postconditions create additional synchronization or encapsulation requirements. If certain states are invalid, then the underlying state variables must be encapsulated, otherwise client code could put the object into an invalid state. If an operation has invalid state transitions, it must be made atomic. On the other hand, if the class does not impose any such constraints, we may be able to relax encapsulation or serialization requirements to obtain greater flexibility or better performance.  </p>
<blockquote>
<p>状态变量的合法性由封装保护，合法的状态转换由原子性保护，如果一个类没有强加这么多限制，可以方法封装和序列化需求以获得更好的灵活性和性能。</p>
</blockquote>
<p>You cannot ensure thread safety without understanding an object’s invariants and postconditions. Constraints on the valid values or state transitions for state variables can create atomicity and encapsulation requirements.  </p>
<blockquote>
<p>如果不了解对象的不变性条件和后置条件，那么就无法保证线程安全性（简单的说就是你要了解对象变量有哪些限制和相互约束以满足你的业务场景），对于状态变量的合法值和状态转换会产生原子性和封装需求。</p>
</blockquote>
<h4 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h4><p>如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。在并发程序中要一直等到先验条件为真时，然后再执行该操作。</p>
<p>要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如Blocking Queue或信号量Semaphore）来实现依赖状态的行为。</p>
<h3 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h3><p><strong>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</strong></p>
<p>实例封闭是构建线程安全类的一个最简单方式，它还使得在锁策略的选择上拥有了更多的灵活性，但对于其他形式的锁来说，只要自始至终都使用同一个锁，就可以保护状态。实例封闭还使得不同的状态变量可以由不同的锁来保护。</p>
<p>Collections.synchronizedList可以用来生成一个线程安全的List，类似的还有Collections.synchronizedSet(Set<T> set)，Collections.synchronizedMap(Map&lt;K, V&gt; map)，Collections.synchronizedCollection(Collection<T> collection)</T></T></p>
<p>当发布其他对象时，例如迭代器或内部的类实例，可能会间接地发布被封闭对象，同样会使被封闭对象逸出。</p>
<blockquote>
<p>Confined objects can also escape by publishing other objects such as iterators or inner class instances that may indirectly publish the confined objects  </p>
</blockquote>
<p>Confinement makes it easier to build thread-safe classes because a class that confines its state can be analyzed for thread safety without having to<br>examine the whole program.  </p>
<h4 id="java监视器模式"><a href="#java监视器模式" class="headerlink" title="java监视器模式"></a>java监视器模式</h4><p>java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都是用该锁对象，都可以用来保护对象的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;myLock&quot;)</span> Widget widget;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(myLock) &#123;</span><br><span class="line">        <span class="comment">// Access or modify the state of widget</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用私有的锁对象而不是对象的内置锁（<strong>就是锁class，因为客户代码也可以锁class但不能锁这个class里面的private</strong>）（或任何其他可通过公有方式访问的锁）<strong>有许多优点</strong>，私有的锁对象可以将锁封装起来，使客户代码无法得到锁，因为如果客户代码可以通过公有方法来访问锁，那么就可以（正确或者不正确地）参与到它地同步策略中。如果客户代码错误地获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个能被公共访问的锁在程序中是否被正确的使用，则需要检查整个程序，而不是单个的类。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在某种程度上，这种实现方式（以下代码）是通过在返回客户代码之前复制可变的数据来维持线程安全性的，通常情况下，这并不存在性能问题，但在车辆容器非常大的情况下将极大地降低性能，此外由于每次调用getLocation就要复制数据，因此将出现一种错误——the contents of the returned collection do not change even if the underlying locations change.  这种情况是好是坏要取决于你的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorVehicleTracker</span> &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MutablePoint&gt; locations;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MonitorVehicleTracker</span><span class="params">(Map&lt;String, MutablePoint&gt; locations)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.locations = deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String, MutablePoint&gt; <span class="title function_">getLocations</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title function_">getLocation</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="type">MutablePoint</span> <span class="variable">loc</span> <span class="operator">=</span> locations.get(id);</span><br><span class="line">        <span class="keyword">return</span> loc == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">MutablePoint</span>(loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String id, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">MutablePoint</span> <span class="variable">loc</span> <span class="operator">=</span> locations.get(id);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="literal">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No such ID: &quot;</span> + id);</span><br><span class="line">        loc.x = x;</span><br><span class="line">        loc.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MutablePoint&gt; <span class="title function_">deepCopy</span><span class="params">(Map&lt;String, MutablePoint&gt; m)</span> &#123;</span><br><span class="line">        Map&lt;String, MutablePoint&gt; result =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, MutablePoint&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String id : m.keySet())</span><br><span class="line">        	result.put(id, <span class="keyword">new</span> <span class="title class_">MutablePoint</span>(m.get(id)));</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutablePoint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePoint</span><span class="params">()</span> &#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutablePoint</span><span class="params">(MutablePoint p)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = p.x;</span><br><span class="line">        <span class="built_in">this</span>.y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全性的委托"><a href="#线程安全性的委托" class="headerlink" title="线程安全性的委托"></a>线程安全性的委托</h3><h4 id="基于委托的车辆追踪器"><a href="#基于委托的车辆追踪器" class="headerlink" title="基于委托的车辆追踪器"></a>基于委托的车辆追踪器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Point类是不可变的，因而它是线程安全的，不可变的值可以被自由地共享与发布，因此在返回locations不需要复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingVehicleTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DelegatingVehicleTracker</span><span class="params">(Map&lt;String, Point&gt; points)</span> &#123;</span><br><span class="line">        locations = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Point&gt;(points);</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title function_">getLocations</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getLocation</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String id, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> <span class="title class_">Point</span>(x, y)) == <span class="literal">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid vehicle name: &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意地是我们稍微改变了车辆追踪器地行为，在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托的车辆追踪器中返回的是一个不可修改但却实时的车辆位置视图，这意味着如果线程A调用getLocations而线程B在随后修改了某些点的位置，那么在返回给线程A的Map中将反映出这些变化。在前面提到过这可能是一种优点也可能是一种缺点。</p>
<p>如果需要一个不发生变化的车辆视图，那么getLocations可以返回对lications这个Map对象的一个浅拷贝，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title function_">getLocations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//new HashMap&lt;String, Point&gt;(locations)只会复制当前时刻的数据，之后locations的变化不会反映在返回值中</span></span><br><span class="line">	<span class="keyword">return</span> Collections.unmodifiableMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Point&gt;(locations));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="当委托失效时"><a href="#当委托失效时" class="headerlink" title="当委托失效时"></a>当委托失效时</h4><p>If a class is composed of multiple independent thread-safe state variables and has no operations that have any invalid state transitions, then it can delegate thread safety to the underlying state variables.  </p>
<p>如果一个类由多个独立且线程安全的状态变量组成，且在所有操作中不存在往无效状态的转换，那么可以将线程安全性委托给这些底层的状态变量。</p>
<h4 id="示例：发布状态的车辆追踪器"><a href="#示例：发布状态的车辆追踪器" class="headerlink" title="示例：发布状态的车辆追踪器"></a>示例：发布状态的车辆追踪器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafePoint</span> &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafePoint</span><span class="params">(<span class="type">int</span>[] a)</span> &#123; <span class="built_in">this</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafePoint</span><span class="params">(SafePoint p)</span> &#123; <span class="built_in">this</span>(p.get()); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafePoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishingVehicleTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PublishingVehicleTracker</span><span class="params">(Map&lt;String, SafePoint&gt; locations)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.locations= <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, SafePoint&gt;(locations);</span><br><span class="line">        <span class="built_in">this</span>.unmodifiableMap= Collections.unmodifiableMap(<span class="built_in">this</span>.locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title function_">getLocations</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SafePoint <span class="title function_">getLocation</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocation</span><span class="params">(String id, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!locations.containsKey(id))</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid vehicle name: &quot;</span> + id);</span><br><span class="line">    	locations.get(id).set(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map中的元素改成了线程安全且可变的SafePoint，而并非之前不可变的Point。getLocations返回Map对象的一个不可变副本，调用者不能增加或删除车辆，但却可以通过修改返回Map中的SafePoint值来改变车辆的位置。</p>
<p>PublishingVehicleTracker is thread-safe, but would not be so if it imposed any additional constraints on the valid values for vehicle locations.   </p>
<blockquote>
<p>如果PublishingVehicleTracker对未知添加了其他限制时那么就不是线程安全的，因为无法避免客户代码修改位置信息，除非直接在SafePoint添加限制</p>
</blockquote>
<h3 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h3><p>要添加一个新的原子操作，最安全的方法是修改原始的类，这需要理解代码中的同步策略，这样增加的功能才能与原有的涉及保持一致。</p>
<p>另一种方法是扩展这个类，“扩展”方法比直接将代码添加到类中更加脆弱，因为同步策略被分布到多个单独维护的源代码文件里。如果底层的类改变了同步策略，那么子类会被破坏，因为在同步策略改变后无法再使用正确的锁来控制对基类状态的并发访问。</p>
<h4 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h4><p>The documentation for Vector and the synchronized wrapper classes states, albeit obliquely, that they support client-side locking, by using the intrinsic lock for the Vector or the wrapper collection (not the wrapped collection). Listing 4.15 shows a putIfAbsent operation on a thread-safe List that correctly uses client-side locking.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListHelper</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(E x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">absent</span> <span class="operator">=</span> !list.contains(x);</span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">            	list.add(x);</span><br><span class="line">            <span class="keyword">return</span> absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If extending a class to add another atomic operation is fragile because it distributes the locking code for a class over multiple classes in an object hierarchy, client-side locking is even more fragile because it entails putting locking code for class C into classes that are totally unrelated to C. Exercise care when using client-side locking on classes that do not commit to their locking strategy.  </p>
<p>客户端加锁机制与继承类机制有许多共同点，两者都是将派生类的行为与基类的实现耦合在一起，正如继承会破坏实现的封装性，客户端加锁也会破坏同步策略的封装性。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>There is a less fragile alternative for adding an atomic operation to an existing class: composition. ImprovedList in Listing 4.16 implements the List operations by delegating them to an underlying List instance, and adds an atomic putIfAbsent method.   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImprovedList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> &#123; <span class="built_in">this</span>.list = list; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">putIfAbsent</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">        	list.add(x);</span><br><span class="line">        <span class="keyword">return</span> !contains;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123; list.clear(); &#125;</span><br><span class="line">    <span class="comment">// ... similarly delegate other List methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImprovedList adds an additional level of locking using its own intrinsic lock. It does not care whether the underlying List is thread-safe, because it provides its own consistent locking that provides thread safety even if the List is not thread-safe or changes its locking implementation. While the extra layer of synchronization may add some small performance penalty,7 the implementation in ImprovedList is less fragile than attempting to mimic the locking strategy of another object. In effect, we’ve used the Java monitor pattern to encapsulate an existing List, and this is guaranteed to provide thread safety so long as our class holds the only outstanding reference to the underlying List.  </p>
<blockquote>
<p>好处是无论底层是否线程安全，因为唯一持有底层实例，并且用监视器模式重载了所有方法，所以一定是线程安全和健壮的，缺点是工作量</p>
</blockquote>
<h3 id="同步策略文档化"><a href="#同步策略文档化" class="headerlink" title="同步策略文档化"></a>同步策略文档化</h3><p>在维护线程安全性时，文档时最强大的工具之一。可以通过查阅文档来判断某个类是否是线程安全的，也可以用来理解同步策略，避免破坏安全性，然而现实中人们从文档中获取的信息却是少之又少。</p>
<h2 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h2><h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><p>同步容器类包括Vector和Hashtable，这些同步的封装器类是由Collections.synchronizedXXX等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h4 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h4><p>The synchronized collection classes guard each method with the lock on the synchronized collection object itself.  </p>
<p>其实就是说，虽然同步容器类是线程安全的，但是如果要扩展复合操作的话，还是需要遵从同步容器类的同步策略</p>
<h4 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h4><p>ConcurrentModificationException的实现方式是将计数器的变化和容器关联起来，如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException，然而这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。这是一种设计上的权衡，从而降低并发修改操作的检测代码对程序性能带来的影响。</p>
<p>如果不希望再迭代期间对容器加锁，那么一种替代方法就是克隆容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会再迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException（在克隆过程中仍然需要对容器加锁）。在克隆容器时存在显著的性能开销，这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，迭代操作的调用频率，以及在响应时间和吞吐量等方面的需求。</p>
<h4 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenIterator</span> &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer i)</span> &#123; set.add(i); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Integer i)</span> &#123; set.remove(i); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTenThings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        	add(r.nextInt());</span><br><span class="line">        System.out.println(<span class="string">&quot;DEBUG: added ten elements to &quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印set会隐式调用迭代，因此addTenThings方法可能会抛出ConcurrentModificationException，因为在生成调试消息的过程中，toString对容器进行迭代。</p>
<p>The real lesson here is that the greater the distance between the state and the synchronization that guards it, the more likely that someone will forget to use proper synchronization when accessing that state.   </p>
<blockquote>
<p>状态和同步之间隔得越远，越容易忽视同步的使用</p>
</blockquote>
<p>容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个同期地元素或键值时，就会出现这种情况（触发容器的hashCode和equals等方法）。同样，containsAll，removeAll和retainAll等方法以及把容器作为参数的构造函数，都会对容器进行迭代。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>同步容器类的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。</p>
<blockquote>
<p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险</p>
</blockquote>
<p><strong>ConcurrentHashMap</strong>, a replacement for synchronized hash-based Map implementations  </p>
<p><strong>CopyOnWriteArrayList</strong>, a replacement for synchronized List implementations for cases where traversal is the dominant operation  </p>
<p><strong>CopyOnWriteArrayList</strong>, a replacement for synchronized List implementations for cases where traversal is the dominant operation  </p>
<p><strong>Queue</strong> and <strong>BlockingQueue</strong>. A <strong>Queue</strong> is intended to hold a set of elements temporarily while they await processing.  Several implementations are provided, including <strong>ConcurrentLinkedQueue</strong>,  and <strong>PriorityQueue</strong>, a (non concurrent) priority ordered queue.  <strong>Queue</strong> operations do not block; if the queue is empty, the retrieval operation returns null ，你可能会觉得可以用List代替Queue，事实上LinkedList也确实实现了Queue，但Queue还是有必要的，因为它忽略掉了随机access（List的get方法）的需求后可以保证更大的并发效率。</p>
<p><strong>BlockingQueue</strong>扩展了Queue，增加了可阻塞的插入和获取操作，如果队列为空，那么获取元素的操作将一直阻塞，指导队列中出现一个可用的元素，如果队列已满（有界队列），那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。</p>
<p>Just as <strong>ConcurrentHashMap</strong> is a concurrent replacement for a synchronized hash-based Map, Java 6 adds <strong>ConcurrentSkipListMap</strong> and <strong>ConcurrentSkipListSet</strong>, which are concurrent replacements for a synchronized SortedMap or SortedSet (such as TreeMap or TreeSet wrapped with synchronizedMap).  </p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如HashMap.get或List.contains可能包含大量的工作：当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用equals（而equals本身还包含一定的计算量）而其他线程在这段时间内都不能访问该容器。</p>
<p>ConcurrentHashMap使用了分段锁，这种机制中，任意数量的读取线程可以并发地访问Map，执行读取操作地线程和执行写入操作地线程可以并发地访问Map，并且一定数量地写入线程可以并发地修改Map。</p>
<p>尽管有这些改进，但仍然有一些需要权衡的因素，对于一些需要在整个Map上进行计算的方法，例如size和isEmpty，这些方法的语义被略微减弱了以反映容器的并发特性，由于size返回的结果在计算时可能已经过期了，它实际上只是一个估计值，因此允许size返回一个近似值而不是一个精确值，虽然这看上去有些令人不安，但实际上size和isEmpty这样的方法在并发环境下的用处很小，因为它们的返回值总在不断变化，因此这些操作的需求被弱化了，以换取对其他更重要操作的性能优化，包括get，put，containsKey和remove等。</p>
<p>在ConcurrentHashMap中没有实现对Map加锁以提供独占访问。在Hashtable和synchronizedMap中，获得Map的锁能防止其他线程访问这个Map，在一些不常见的情况中需要这种功能，例如通过原子方式添加一些映射，或者对Map迭代若干次并在此期间保持元素顺序相同，然而，总体来说这种权衡还是合理的，因为并发容器的内容会持续变化。</p>
<p>与HashTable和synchronizedMap相比，ConcurrentHashMap有着更多的优势以及更少的劣势，因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一步提高代码的可伸缩性，只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用ConcurrentHashMap。</p>
<h4 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h4><p>Instead, a number of common compound operations such as put-if-absent, remove-if-equal, and replace-if-equal are implemented as atomic operations and specified by the ConcurrentMap interface, shown in Listing 5.7. If you find yourself adding such functionality to an existing synchronized Map implementation, it is probably a sign that you should consider using a ConcurrentMap instead.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// Insert into map only if no value is mapped from K</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">// Remove only if K is mapped to V</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">// Replace value only if K is mapped to oldValue</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">// Replace value only if K is mapped to some value</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V newValue)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽量用ConcurrentMap已有的复合操作，因为你无法对ConcurrentMap进行客户端加锁（你都不知道底层用的什么锁）</p>
</blockquote>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p><strong>CopyOnWriteArrayList</strong> is a concurrent replacement for a synchronized <strong>List</strong> that offers better concurrency in some common situations and eliminates the need to lock or copy the collection during iteration. (Similarly, <strong>CopyOnWriteArraySet</strong> is a concurrent replacement for a synchronized <strong>Set</strong>.)  </p>
<p>The copy-on-write collections derive their thread safety from the fact that as long as an effectively immutable object is properly published, no further synchronization is required when accessing it. They implement mutability by creating and republishing a new copy of the collection every time it is modified. Iterators for the copy-on-write collections retain a reference to the backing array that was current at the start of iteration, and since this will never change, they need to  synchronize only briefly to ensure visibility of the array contents. <strong>As a result, multiple threads can iterate the collection without interference from one another or from threads wanting to modify the collection. The iterators returned by the copy-on-write collections do not throw ConcurrentModificationException and return the elements exactly as they were at the time the iterator was created, regardless of subsequent modifications</strong>.  </p>
<blockquote>
<p>copy-on-write集合的迭代器在创建的时候内容就固定了，随后的更改（会创建一个新的副本）不会影响迭代器，也不会抛出异常</p>
</blockquote>
<p>显然，每当修改容器时都会复制底层数组，这会带来一定的开销，特别是当容器的规模较大时，仅当迭代操作远远多于修改操作时（读大于写）时才应该使用copy-on-write容器。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>在构建高可用的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p>
<blockquote>
<p>Based on these differences, you can choose between ArrayList and LinkedList based on your specific requirements. If you need fast random access and frequently perform insertions or deletions at the beginning or middle of the list, ArrayList may be a better choice. On the other hand, if you frequently perform insertions or deletions at any position in the list and random access is not a priority, LinkedList may be more suitable.</p>
</blockquote>
<p>在类库中包含了BlockingQueue的多种实现，<strong>LinkedBlockingQueue</strong>和<strong>ArrayBlockingQueue</strong>是FIFO队列，两者分别与LinkedList和ArrayList类似，但比同步List拥有更好的并发性能，<strong>PriorityBlockingQueue</strong>是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。</p>
<p>最后一个BlockingQueue实现是SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待者把元素加入或逸出队列。这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p>
<h4 id="双端队列和工作密取"><a href="#双端队列和工作密取" class="headerlink" title="双端队列和工作密取"></a>双端队列和工作密取</h4><p>双端队列同样适用于另一种相关模式，即工作密取。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密的获取工作。</p>
<p>工作密取非常适用于既是消费者也是生产者的问题——当执行某个工作时可能导致出现更多的工作。</p>
<h3 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h3><p>阻塞操作与执行时间很长的普通操作的差别在于，被阻塞的线程必须等待某个不受他控制的事件发生后才能继续执行，例如等待IO操作完成，等待某个锁变成可用，或者等待外部计算的结束。</p>
<p>BlockingQueue的put和take方法会抛出InterruptedException，表明该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。</p>
<p>Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断，每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。</p>
<p><strong>中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作</strong>。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——<strong>前提是如果线程B愿意停止下来</strong>。方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。</p>
<p>当在代码中调用了一个将抛出InterruptedException异常的方法时，必须要处理对中断的响应。有两种选择：</p>
<ul>
<li>传递InterruptedException</li>
<li>恢复中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	processTask(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        	<span class="comment">// restore interrupted status</span></span><br><span class="line">        	Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在出现InterruptedException时不应该做的事是，捕获它但不做出任何响应。</p>
<h3 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h3><h4 id="闭锁（latch）"><a href="#闭锁（latch）" class="headerlink" title="闭锁（latch）"></a>闭锁（latch）</h4><p>闭锁是一种同步工具类，可以延迟线程的进度知道其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。</p>
<blockquote>
<p>闭锁和我们常用的wait-notify机制的优势在于它提供了一个中间过程，await的线程可以等待多个其他的线程的事件就绪而不是单单只能等待一个线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHarness</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">timeTasks</span><span class="params">(<span class="type">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">endGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	task.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    	endGate.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在TestHarness中使用闭锁，而不是在线程创建后就立即启动？如果在创建线程后立即启动它们，那么先启动的线程将“领先”后启动的线程，并且活跃线程数量会随着事件的推移而增加或减少，竞争程度也在不断发生变化。startGate将使得主线程能够同时释放所有工作线程，而endGate则使主线程能够等待最后一个线程执行完成，而不是顺序地等待每个线程执行完成。</p>
<h4 id="futuretask"><a href="#futuretask" class="headerlink" title="futuretask"></a>futuretask</h4><h4 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h4><p>计数信号量用来控制同时访问某个特定资源地操作数量，或者同时执行某个指定操作的数量。</p>
<p>semaphore中管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可。release方法将返回一个许可给信号量，计算信号量的一种简化形式是二值信号量，即初始值为1的semaphore，二值信号量可以用作互斥体，并具备不可重入的加锁语义，谁拥有这个唯一的许可，谁就拥有了互斥锁。</p>
<blockquote>
<p>信号量和闭锁相比增加了一个“资源”的概念，这个资源在不可用时会阻塞，不同线程之间存在竞争关系，而闭锁只是一个阀门，线程之间不存在竞争关系。</p>
</blockquote>
<h4 id="栅栏（barrier）"><a href="#栅栏（barrier）" class="headerlink" title="栅栏（barrier）"></a>栅栏（barrier）</h4><p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须都达到栅栏位置（<strong>也就是说先到达栅栏位置的线程会阻塞用于等待其他线程</strong>），才能继续执行。</p>
<blockquote>
<p>那么前面TestHarness的例子就可以改写为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHarness</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">timeTasks</span><span class="params">(<span class="type">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//+1是为了让主线程来摧毁最后的栅栏，不然的话有可能直接在for循环里就会把barrier放开了，或者某个线程会阻塞住（因为主线程占用了一个栅栏）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">startGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(nThreads+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">endGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(nThreads+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	task.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    	endGate.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//最后一个barrier达成,各线程开始执行task</span></span><br><span class="line">        startGate.await();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一种形式的栅栏是Exchanger，它是一种两方栅栏，各方在栅栏位置上交换数据。</p>
<h4 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h4><blockquote>
<p>看原文，关键点是在ConrrentHashMap里用future代替了值</p>
</blockquote>
<h3 id="第一部分小结"><a href="#第一部分小结" class="headerlink" title="第一部分小结"></a>第一部分小结</h3><ul>
<li>It’s the mutable state, stupid.1<br>All concurrency issues boil down to coordinating access to mutable state. The less mutable state, the easier it is to ensure thread safety.</li>
<li>Make fields final unless they need to be mutable.</li>
<li>Immutable objects are automatically thread-safe.<br>Immutable objects simplify concurrent programming tremendously. They are simpler and safer, and can be shared freely without locking or defensive copying.</li>
<li>Encapsulation makes it practical to manage the complexity.<br>You could write a thread-safe program with all data stored in global variables, but why would you want to? Encapsulating data within objects makes it easier to preserve their invariants; encapsulating synchronization within objects makes it easier to comply with their synchronization policy.</li>
<li>Guard each mutable variable with a lock.</li>
<li>Guard all variables in an invariant with the same lock.</li>
<li>Hold locks for the duration of compound actions.</li>
<li>A program that accesses a mutable variable from multiple threads without synchronization is a broken program.</li>
<li>Don’t rely on clever reasoning about why you don’t need to synchronize.</li>
<li>Include thread safety in the design process—or explicitly document that your class is not thread-safe.</li>
<li>Document your synchronization policy</li>
</ul>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><h3 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h3><h4 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h4><h4 id="显式的为任务创建线程"><a href="#显式的为任务创建线程" class="headerlink" title="显式的为任务创建线程"></a>显式的为任务创建线程</h4><h4 id="无限创建线程的不足"><a href="#无限创建线程的不足" class="headerlink" title="无限创建线程的不足"></a>无限创建线程的不足</h4><p><strong>线程生命周期的开销非常高</strong>，线程的创建与销毁并不是没有代价的，根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，导致处理的延迟，而且需要JVM和操作系统的一些操作与活动，如果请求的到达率非常高且请求的处理过程是轻量级的，例如大多数服务器应用程序就是这种情况，那么为每个请求创建一个新线程将小号大量的计算资源。</p>
<p><strong>资源消耗</strong>。活跃的线程会消耗系统资源尤其是内存。如果可运行的线程数量多余可用处理器的数量，那么有些线程将闲置，大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销，如果你已经拥有足够多的线程使所有的CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</p>
<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者，如果要在程序中实现一个生产者-消费者的设计，那么最简单的方式通常就是使用Executor。</p>
<blockquote>
<p>这样连队列都不用定义了</p>
</blockquote>
<h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p>每当看到入选面这种形式的代码时：</p>
<blockquote>
<p>new Thread(runnable).start()</p>
</blockquote>
<p>并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li><strong>newFixedThreadPool</strong>. A fixed-size thread pool creates threads as tasks are submitted, up to the maximum pool size, and then attempts to keep the pool size constant (adding new threads if a thread dies due to an unexpected Exception).</li>
<li><strong>newCachedThreadPool.</strong> A cached thread pool has more flexibility to reap idle threads when the current size of the pool exceeds the demand for processing, and to add new threads when demand increases, but places no bounds on the size of the pool.</li>
<li><strong>newSingleThreadExecutor</strong>. A single-threaded executor creates a single worker thread to process tasks, replacing it if it dies unexpectedly. Tasks are guaranteed to be processed sequentially according to the order imposed by the task queue (FIFO, LIFO, priority order).4</li>
<li><strong>newScheduledThreadPool</strong>. A fixed-size thread pool that supports delayed and periodic task execution, similar to Timer. (See Section 6.2.5.)</li>
</ul>
<p>The newFixedThreadPool and newCachedThreadPool factories return instances of the general-purpose ThreadPoolExecutor, which can also be used<br>directly to construct more specialized executors  </p>
<h4 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h4><p>为了解决生命周期的问题，ExecutorService扩展了Executor接口，添加了一些用于生命周期管理的方法。</p>
<p>ExecutorService有三种状态，running，shutting down，和terminated，ExecutorService创建时是running状态，shutdown方法执行平缓的关闭过程（不接受新任务，等待已提交的任务执行完成——即使还没有开始），shutdownNow方法执行暴力关闭，它<strong>尝试</strong>取消所有运行中的任务，并且不再启动队列中尚未开始的任务。</p>
<p>ExecutorService关闭后再执行execute会抛出异常。可以用调用awaitTermination来等待ExecutorService到达terminated状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止，<strong>通常在调用shutdown后会立即调用awaitTermination来产生同步关闭ExecutorService的效果</strong>。</p>
<h4 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h4><p>Timer存在缺陷——Timer在执行所有定时任务时只会创建一个线程。且Timer线程并不捕获异常，因此当任务抛出未检查的异常时将终止定时线程。Timer也不会恢复线程的执行，而是会错误的认为整个Timer都被取消了。</p>
<blockquote>
<p>用<strong>ScheduledThreadPoolExecutor</strong>！不要用Timer！</p>
</blockquote>
<p>DelayQueue实现了BlockingQueue，为ScheduledThreadPoolExecutor提供调度功能，DelayQueue管理着一组Delayed对象，每个Delayed对象都有一个相应的延迟时间，在DelayQueue中只有某个元素到达指定延时时间后才能从DelayQueue中take出来。</p>
<h3 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h3><h4 id="携带结果的任务Callable和Future"><a href="#携带结果的任务Callable和Future" class="headerlink" title="携带结果的任务Callable和Future"></a>携带结果的任务Callable和Future</h4><p>在Executor框架中，已提交但尚未开始的任务可以取消，但对于哪些已经开始执行的任务，只有当他们能响应中断时，才能取消。</p>
<p>如果future任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出，如果任务被取消，那么get将抛出CancellationException。如果get抛出了ExecutionExecption，那么可以通过getCause来获取被封装的初始异常。</p>
<blockquote>
<p>futuretask是future的实现类</p>
</blockquote>
<h4 id="在异构任务并行化中存在的局限"><a href="#在异构任务并行化中存在的局限" class="headerlink" title="在异构任务并行化中存在的局限"></a>在异构任务并行化中存在的局限</h4><p>只有当大量互相独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。</p>
<h4 id="CompletionService：Execution与BlockingQueue"><a href="#CompletionService：Execution与BlockingQueue" class="headerlink" title="CompletionService：Execution与BlockingQueue"></a>CompletionService：Execution与BlockingQueue</h4><p>CompletionService将Executor与BlockingQueue的功能融合在一起，你可以将Callable任务提交给它来执行，然后用类似队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时被封装为Future。</p>
<blockquote>
<p>take的时候貌似无法与submit的任务一一对应，先执行完的先进入队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Renderer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">	Renderer(ExecutorService executor) &#123; <span class="built_in">this</span>.executor = executor; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span> &#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;ImageData&gt;(executor);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;ImageData&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> ImageData <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">                	<span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                <span class="type">ImageData</span> <span class="variable">imageData</span> <span class="operator">=</span> f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        	Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="为任务设置时限"><a href="#为任务设置时限" class="headerlink" title="为任务设置时限"></a>为任务设置时限</h4><p>在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后中止执行或取消任务。此时可再次使用Future，如果一个限时的get方法抛出了TimeOutException，那么可以通过future来取消任务，如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureRenderer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">renderPage</span><span class="params">(CharSequence source)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> List&lt;ImageData&gt; <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ImageData&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos)</span><br><span class="line">            	result.add(imageInfo.downloadImage());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">            	renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Re-assert the thread’s interrupted status</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// We don’t need the result, so cancel the task too</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Page <span class="title function_">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endNanos</span> <span class="operator">=</span> System.nanoTime() + TIME_BUDGET;</span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> <span class="title class_">FetchAdTask</span>());</span><br><span class="line">    <span class="comment">// Render the page while waiting for the ad</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">page</span> <span class="operator">=</span> renderPageBody();</span><br><span class="line">    Ad ad;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Only wait for the remaining time budget</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeLeft</span> <span class="operator">=</span> endNanos - System.nanoTime();</span><br><span class="line">        ad = f.get(timeLeft, NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        	ad = DEFAULT_AD;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">            f.cancel(<span class="literal">true</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    page.setAd(ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建n个任务，将其提交到一个线程池，保留n个future并使用限时的get方法通过future串行的获取每个结果，这一切都很简单，但还有个更简单的方法——invokeAll。</p>
<p>invokeAll方法的参数为一组任务并返回一组future，这两个集合有着相同的结构，invokerAll按照任务集合中迭代器的顺序将所有的future添加到返回的集合中，从何使调用者能将各个future与其标识的callable关联起来。当所有任务都执行完毕后，或者调用线程被中断时，又或者超过指定时限时，invokeAll将返回。当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务那么正常的完成，那么被取消，而客户端代码可以调用get或isCancelled来判断究竟是何种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QuoteTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;TravelQuote&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> TravelQuote <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title function_">getRankedTravelQuotes</span><span class="params">(</span></span><br><span class="line"><span class="params">        TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies,</span></span><br><span class="line"><span class="params">        Comparator&lt;TravelQuote&gt; ranking, <span class="type">long</span> time, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;QuoteTask&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TravelCompany company : companies)</span><br><span class="line">        	tasks.add(<span class="keyword">new</span> <span class="title class_">QuoteTask</span>(company, travelInfo));</span><br><span class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line">        List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TravelQuote&gt;(tasks.size());</span><br><span class="line">        Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">        	<span class="type">QuoteTask</span> <span class="variable">task</span> <span class="operator">=</span> taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	quotes.add(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            	quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">            	quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(quotes, ranking);</span><br><span class="line">        <span class="keyword">return</span> quotes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h2><p>java没有提供任何机制来安全地终止线程，但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<p>在编写任务和服务时可以使用一种协作的方式，当需要停止时，它们首先会清除当前正在执行的工作，然后在结束，这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清楚工作。</p>
<p>生命周期结束的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略，<strong>一个在行为良好的软件与勉强运行的软件之间的最主要区别就是，行为良好的软件能很完善的处理失败、关闭和取消等过程</strong>。</p>
<h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><p>如果外部代码能在某个操作正常完成之前将其置为“完成”状态，那么这个操作就可以称为“可取消的”。</p>
<p>java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<p>其中一种协作机制能设计某个“取消”标志位，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。</p>
<p>一个可取消地任务必须拥有取消策略，这个策略中将详细定义取消操作的how，when以及what，即其他代码如何取消该任务，任务在何时检查是否已经请求了取消，以及在响应取消请求时应该执行哪些操作。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。</p>
<blockquote>
<p>在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。</p>
</blockquote>
<p>每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被设置为true。</p>
<p>interrupt方法能中断目标线程，而isTnterrupted方法能返回目标线程的中断状态，静态的interrupted方法将清楚当前线程的中断状态，并返回它之前的值，这也是清楚中断状态的唯一方法。</p>
<p>阻塞方法例如sleep和wait等<strong>，在响应中断时执行的操作包括：清除中断状态，抛出InterruptionException，标识阻塞操作由于中断而提前结束</strong>。</p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。如果不触发InterruptedException，那么中断状态将一直保持，直到明确的清除中断状态。</p>
<blockquote>
<p>如果设置了中断状态，下一次sleep或wait会直接触发InterruptedException</p>
</blockquote>
<p>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>
<p>有些方法，例如wait、sleep和join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，<strong>将抛出一个异常</strong>。</p>
<p>使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException。或者通过再次调用interrupt来恢复中断状态。</p>
<blockquote>
<p>通常，中断是实现取消的最合理方式。</p>
</blockquote>
<h4 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h4><p>如果除了将InterruptedException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptedException之后恢复中断状态。</p>
<blockquote>
<p>Thread.currentThread().interrupt()</p>
</blockquote>
<blockquote>
<p>由于每个线程拥有各自的中断策略，因此除非你直到中断对该线程的含义，否则就不应该中断这个线程</p>
</blockquote>
<h4 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h4><p>在调用可中断的阻塞函数时，有两种实用策略可用于处理InterruptedException：</p>
<ul>
<li>传递异常（可能在执行某些清除操作之后），从而使你的方法也成为可中断的阻塞方法</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理</li>
</ul>
<blockquote>
<p>中断线程之前，应该了解它的中断策略，简单点说，你应该直到你要中断的线程会如何响应中断</p>
</blockquote>
<h4 id="通过future来实现取消"><a href="#通过future来实现取消" class="headerlink" title="通过future来实现取消"></a>通过future来实现取消</h4><p>future拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，并且返回一个标识表示取消操作是否成功。</p>
<blockquote>
<p>这个标识只是表示是否传递了中断，而不是表示任务能检测并处理中断</p>
</blockquote>
<p>mayInterruptIfRunning的处理</p>
<table>
<thead>
<tr>
<th></th>
<th>任务运行中</th>
<th>任务未开始</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>线程中断</td>
<td>不会开始</td>
</tr>
<tr>
<td>false</td>
<td>不会中断（感觉没意义）</td>
<td>不会开始</td>
</tr>
</tbody></table>
<p>Executor实现了一种中断策略使得任务可以通过中断被取消，所以如果任务在标准executor中运行并通过它们的future来取消任务，那么可以设置mayInterruptIfRunning。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">timedRun</span><span class="params">(Runnable r,<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	task.get(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    	<span class="comment">// task will be cancelled below</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    	<span class="comment">// exception thrown in task; rethrow</span></span><br><span class="line">        <span class="comment">//重新抛出异常，这里很关键</span></span><br><span class="line">    	<span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//不再需要结果，必须立马结束</span></span><br><span class="line">        <span class="comment">// Harmless if task already completed</span></span><br><span class="line">        task.cancel(<span class="literal">true</span>); <span class="comment">// interrupt if running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当future.get抛出InterruptedException或TimeoutException时，如果你直到不再需要结果，那么久可以调用future.get来取消任务。</p>
<h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>然而并非所有的可阻塞方法或者阻塞机制都能响应中断；如果一个线程由于执行同步Socket IO或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用</p>
<p>We can sometimes convince threads blocked in noninterruptible activities to stop by means similar to interruption, but this requires greater awareness of why the thread is blocked.  </p>
<p>我们也可以用类似中断的方式停止不可中断的任务，但这需要知道为什么线程被阻塞。</p>
<p>java.io包中的同步socket IO。通过关闭底层的套接字，可以使得执行InputStream的read和outputstream的write等方法而被阻塞的线程抛出一个socketException。</p>
<p>java.io包中的同步IO，当<strong>中断</strong>一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并关闭链路（这还会使得其他在这条链路上阻塞的线程同样抛出ClosedByInterruptException），当<strong>关闭</strong>一个InterruptibleChannel时，将导致所有在链路操作上阻塞的线程都抛出AsynchronousCloseException。大多数标准的channel都是实现了InterruptibleChannel。</p>
<p>selector的异步IO，如果一个线程在调用Selector.select方法时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedByInterruptException并提前返回。</p>
<p>获取某个锁，如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。但是，在Lock类中提供了<strong>lockInterruptibly</strong>方法，该方法允许在等待一个锁的同时仍能响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一种可自定义取消操作的callable类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CancellableTask</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line">    RunnableFuture&lt;T&gt; <span class="title function_">newTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">//新定义了一种RunnableFuture的生成方式</span></span><br><span class="line">    <span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable <span class="keyword">instanceof</span> CancellableTask)</span><br><span class="line">        	<span class="keyword">return</span> ((CancellableTask&lt;T&gt;) callable).newTask();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="built_in">super</span>.newTaskFor(callable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了具体的取消操作，这里是以关闭socket为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketUsingTask</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">CancellableTask</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setSocket</span><span class="params">(Socket s)</span> &#123; socket = s; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">        	socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title function_">newTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	SocketUsingTask.<span class="built_in">this</span>.cancel();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                	<span class="keyword">return</span> <span class="built_in">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h3><p>正确封装的原则是：除非拥有某个线程，否则不能对该线程进行操控。</p>
<p>线程有一个相应的所有者，即创建该线程的类，即线程池是其工作线程的所有者，如果要中断这些线程，那么应该使用线程池。</p>
<blockquote>
<p>这里的服务理解成执行特定业务逻辑的线程池</p>
</blockquote>
<p>应用程序可以拥有服务，服务也可以拥有工作线程，但应用程序并不能拥有工作线程，因此应用程序不能直接停止工作线程。相反，服务应该提供生命周期方法来关闭它自己以及它所拥有的线程。这样当应用程序关闭该服务时，服务就可以关闭所有的线程了，在ExecutorService中提供了shutdown和shutdownNow等方法。同样，在其他拥有线程的服务中也应该提供类似的关闭机制。</p>
<blockquote>
<p>对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">boolean</span> isShutdown;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="type">int</span> reservations;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123; loggerThread.start(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; isShutdown = <span class="literal">true</span>; &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(...);</span><br><span class="line">            ++reservations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能放在synchronized里，防止阻塞后不释放锁</span></span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LoggerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (LogService.<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="comment">//关闭后还要把遗留的数据处理掉</span></span><br><span class="line">                        <span class="keyword">if</span> (isShutdown &amp;&amp; reservations == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    <span class="keyword">synchronized</span> (LogService.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    	--reservations;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writer.println(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; <span class="comment">/* retry */</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法invokeAny，invokeAll具有阻塞性。</p>
<ul>
<li>invokeAny取得第一个方法的返回值，当第一个任务结束后，会调用interrupt方法中断其他任务</li>
<li>invokeAll等线程任务执行完毕后，取得全部任务的结果值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">checkMail</span><span class="params">(Set&lt;String&gt; hosts, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">hasNewMail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String host : hosts)</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (checkMail(host))</span><br><span class="line">                        hasNewMail.set(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//shutdown和awaitTermination结合使用可以达到阻塞等到所有任务执行完毕的效果</span></span><br><span class="line">        <span class="comment">//也可以用invokeAll</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        exec.awaitTermination(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasNewMail.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h4><p>shutdownNow如果中断了正在执行的任务，但无法返回未完成的任务，因此作者设计了以下一种被中断后能够记录线程的线程池</p>
<blockquote>
<p>但是任务必须能够将自己的中断状态保持才能运作这个机制，同时这个机制也是有漏洞的，任务结束之后到被线程池标记为结束之前的这段时间，如果线程池被销毁（任务被中断，即runnable.run();到if (isShutdown()&amp;&amp; Thread.currentThread().isInterrupted())之间的时间），那么这个任务也被认为是未完成的，因此这个线程池只能运行幂等的任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCancelledAtShutdown = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Runnable&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">getCancelledTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!exec.isTerminated())</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(...);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Runnable&gt;(tasksCancelledAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> &#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	runnable.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//runnable必须响应中断并且维持这个中断状态,因此不能catch也不能currentThread().interrupted()</span></span><br><span class="line">                	<span class="keyword">if</span> (isShutdown()&amp;&amp; Thread.currentThread().isInterrupted())</span><br><span class="line">                		tasksCancelledAtShutdown.add(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// delegate other ExecutorService methods to exec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>爬虫的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebCrawler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> TrackingExecutor exec;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; urlsToCrawl = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;URL&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        exec = <span class="keyword">new</span> <span class="title class_">TrackingExecutor</span>(</span><br><span class="line">        Executors.newCachedThreadPool());</span><br><span class="line">        <span class="keyword">for</span> (URL url : urlsToCrawl) submitCrawlTask(url);</span><br><span class="line">        	urlsToCrawl.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveUncrawled(exec.shutdownNow());</span><br><span class="line">            <span class="keyword">if</span> (exec.awaitTermination(TIMEOUT, UNIT))</span><br><span class="line">            	saveUncrawled(exec.getCancelledTasks());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	exec = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;URL&gt; <span class="title function_">processPage</span><span class="params">(URL url)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveUncrawled</span><span class="params">(List&lt;Runnable&gt; uncrawled)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable task : uncrawled)</span><br><span class="line">        	urlsToCrawl.add(((CrawlTask) task).getPage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitCrawlTask</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">    	exec.execute(<span class="keyword">new</span> <span class="title class_">CrawlTask</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CrawlTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL link : processPage(url)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                submitCrawlTask(link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> URL <span class="title function_">getPage</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h3><p>如果并发程序中的某个线程发生故障，那么通常并不会如此明显，在控制台中可能会输出栈追踪信息，但没有人会观察控制台，此外，当线程发生故障时，应用程序可能看起来仍然能工作，所以这个失败很可能会被忽略。</p>
<p>导致线程提前死亡的最主要原因是RuntimeException</p>
<p>线程应该在try catch代码块中调用任务，这样就能捕获那些未检查的异常了，或者也可以使用try finally代码块来确保能够知道线程非正常退出的情况，并作出正确的响应。</p>
<p>典型的线程池工作线程结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())</span><br><span class="line">        runTask(getTaskFromWorkQueue());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    	thrown = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	threadExited(<span class="built_in">this</span>, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任务抛出一个未检查异常，那么它将使线程终结，但会首先通知框架该线程已经终结，然后框架可能会用新的线程来代替这个工作线程，也可能不会，这取决于线程池是否正在关闭，或者当前已有足够多的线程能满足需求。</p>
<p>当一个线程由于未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtException异常处理器，如果没有提供任何异常处理器，那么默认的行为时将栈追踪信息输出到System.err</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UncaughtExceptionHandler</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将错误信息以及相应的栈追踪信息写入应用程序日志中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UEHLogger</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.SEVERE,<span class="string">&quot;Thread terminated with exception: &quot;</span> + t.getName(),e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行事件较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。</p>
<p>要为线程池中的所有线程设置一个UncaughtExceptionHandler，需要为ThreadPoolExecutor的构造函数提供一个ThreadFactory。</p>
<p>标准线程池允许发生未捕获异常时结束线程，但由于使用了一个try finally代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致极大的混乱。</p>
<p>如果希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的Runnable和Callable中，或者改写ThreadPoolExecutor的afterExecute方法。</p>
<p>需要注意的时，只有通过execute提交的任务，才能将它抛出的异常交给异常处理器，而通过submit提交的任务，无论时抛出的未检查异常还是已检查异常，都被认为时任务返回状态的一部分。如果一个由submit提交的任务由于抛出了异常而结束，那么这个异常将被Future.get封装在ExecutionException中重新抛出。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>只有当线程本地值得生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</p>
<p>如果正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞，那么就会发生问题，这种现象被称为线程饥饿死锁。只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供地资源或条件，例如某个任务等待另一个任务地返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>
<blockquote>
<p>如果线程池不够大，那么当多个任务通过栅栏Barrier机制来彼此协调时，将导致线程饥饿死锁。</p>
</blockquote>
<blockquote>
<p>每当提交了一个有依赖性的任务时，要清除地知道可能会出现线程“饥饿”死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置限制。</p>
</blockquote>
<h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><p>在代码中通常不会固定线程池的大小，而应该通过某种配置机制来提供，或者根据Runtime.availableProcessors来动态计算。</p>
<p>如果需要执行不同类别的任务，并且他们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。</p>
<p>对于计算密集型的任务，线程池为N+1（即使当计算密集型的线程偶尔由于故障或者其他原因而暂停时，这个“额外”的线程也能确保CPU的时钟周期不会被浪费）</p>
<p>线程数&#x3D;（核数）x（目标CPU利用率，0—1，一般取1）x（1+IO时间&#x2F;计算时间）</p>
<p>可以通过Runtime来获取CPU的数目</p>
<p>int N_CPUS &#x3D; Runtime.getRuntime().availableProcessors();</p>
<p>还有其他影响线程池大小的资源，比如内存，文件句柄，套接字句柄和数据库连接等。</p>
<p>计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。</p>
<blockquote>
<p><strong>所以解码的线程池（如果每个任务都需要数据库操作的话）超过数据库连接上限是没有意义的！！！！！</strong></p>
</blockquote>
<h3 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h3><p>CorePoolSize就是线程池的目标大小，只有在工作队列满了的情况下才会创建超出这个数量的线程。</p>
<blockquote>
<p>就是说大部分时候MaxPoolSize基本用不着…corePoolSize不能为0，不然必须等队列满了才能创建线程，同时可以用allowCoreThreadTimeOut来让coreThread空闲时退出</p>
</blockquote>
<p>newFixedThreadPool——线程池不会超时，无界队列</p>
<p>newCachedThreadPool——MaxPoolSize是Integer.MAX_VALUE，corePoolSize是0</p>
<p>newSingleThreadExecutor——无界队列</p>
<blockquote>
<p>用有界队列更加稳妥，有界队列可以防止资源耗尽的情况发生，但它又带来了新的问题：新的任务怎么办？</p>
</blockquote>
<p>在使用有界的工作队列时，队列的大小与线程池的大小必须一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。</p>
<p>只有当任务是无界的或者可以拒绝任务时，SynchronousQueue（直接将任务从生产者交给消费者，如果没有消费者就创建一个新的线程，否则根据饱和策略这个任务将被拒绝）才有实际价值，在newCachedThreadPool工厂方法中就使用了SynchronousQueue。</p>
<p>如果想进一步控制任务的执行顺序，还可以使用优先级队列，这个队列将根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator来定义的。</p>
<p>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的，如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题，此时应该使用无界的线程池，比如newCachedThreadPool。</p>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>在ThreadFactory中只定义了一个方法newThread。每当线程池需要创建一个新线程时都会调用这个方法。</p>
<p>然而在许多情况下都需要使用定制的线程工厂方法，例如你希望为线程池中的线程指定一个UncaughtExceptionHandler，或者实例化一个定制的Thread类用于执行调试信息的记录。</p>
<p>例如以下，自定义了线程（记录创建数量和存活数量，记录异常日志）和线程池</p>
<blockquote>
<p>把MyAppThread融合进MyThreadFactory就很完美了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_NAME</span> <span class="operator">=</span> <span class="string">&quot;MyAppThread&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">debugLifecycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">created</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">alive</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getAnonymousLogger();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAppThread</span><span class="params">(Runnable r)</span> &#123; <span class="built_in">this</span>(r, DEFAULT_NAME); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(runnable, name + <span class="string">&quot;-&quot;</span> + created.incrementAndGet());</span><br><span class="line">        setUncaughtExceptionHandler(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t,Throwable e)</span> &#123;</span><br><span class="line">                log.log(Level.SEVERE,<span class="string">&quot;UNCAUGHT in thread &quot;</span> + t.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Copy debug flag to ensure consistent value throughout.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> debugLifecycle;</span><br><span class="line">        <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">&quot;Created &quot;</span>+getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            alive.incrementAndGet();</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            alive.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">&quot;Exiting &quot;</span>+getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getThreadsCreated</span><span class="params">()</span> &#123; <span class="keyword">return</span> created.get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getThreadsAlive</span><span class="params">()</span> &#123; <span class="keyword">return</span> alive.get(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getDebug</span><span class="params">()</span> &#123; <span class="keyword">return</span> debugLifecycle; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDebug</span><span class="params">(<span class="type">boolean</span> b)</span> &#123; debugLifecycle = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadFactory</span><span class="params">(String poolName)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAppThread</span>(runnable, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用完ThreadPoolExecutor的构造器后，仍然可以通过setter函数来修改大多数传递给它的构造函数的参数（例如线程池的基本大小，最大大小，存活时间，线程工厂以及拒绝执行处理器）除了newSingleThreadExecutor返回的是一个封装的ExecutorService而不是最初的ThreadPoolExecutor，因为修改会改变它的语义。</p>
<p>如果你不希望有人修改你的执行策略，可以通过unconfigurableExecutorService来包装它。</p>
<h4 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h4><p>ThreadPoolExecutor提供了集中可以在子类化中改写的方法</p>
<p>beforeExecute——如果beforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。</p>
<p>afterExecute——无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用（如果任务在完成后带有一个Error，那么就不会调用afterExecute）</p>
<blockquote>
<p>Error和Exception的区别</p>
<p>Error是JVM级别的不可捕捉的错误，例如OOM和堆栈溢出</p>
</blockquote>
<p>线程池完成关闭时调用terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后，terminated可以用来释放Executor在其生命周期里分配的各种资源，此外还可以执行发送通知，记录日志或者收集finalize统计信息等操作。</p>
<blockquote>
<p>什么时候串行化适合改为并行——当串行循环体里的每个任务的计算开销大于管理一个新任务的开销时，就适合改为并行化</p>
</blockquote>
<h2 id="避免活跃性危险"><a href="#避免活跃性危险" class="headerlink" title="避免活跃性危险"></a>避免活跃性危险</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>应用程序（JVM）在解决死锁问题方面没有数据库服务（能从死锁中恢复）那么强大，当一组Java线程发生死锁时，这些线程永远不能再使用了，恢复应用程序的唯一方式就是中止并重启它。</p>
<h4 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h4><p>如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。</p>
<h4 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: deadlock-prone!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(Account fromAccount,</span></span><br><span class="line"><span class="params">                        Account toAccount,</span></span><br><span class="line"><span class="params">                        DollarAmount amount)</span></span><br><span class="line">    <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看似这个程序是满足顺序加锁原则的，但是锁的对象是依赖于外部输入的，比如线程A调用（X,Y,1）和B线程调用（Y,Z,2）那么就有可能发生死锁。或者最严重的情况，线程A调用（X,Y,1）线程B调用（Y,X,2）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">tieLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> Account toAcct,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> DollarAmount amount)</span></span><br><span class="line">    <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Helper</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAcct.debit(amount);</span><br><span class="line">                toAcct.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fromHash</span> <span class="operator">=</span> System.identityHashCode(fromAcct);</span><br><span class="line">    <span class="type">int</span> <span class="variable">toHash</span> <span class="operator">=</span> System.identityHashCode(toAcct);</span><br><span class="line">    <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">Helper</span>().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">Helper</span>().transfer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tieLock) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Helper</span>().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要所有的锁顺序不会形成一个环形（即获取锁的向量图不会成环）就不会发生死锁，况且上面的程序还考虑了相等的情况，引入了tieLock。</p>
<blockquote>
<p>有些死锁不易发现，如果在持有锁的情况下调用外部某个方法，那么就需要警惕死锁！！！在这个外部方法中可能会获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</p>
</blockquote>
<p>有界线程池&#x2F;资源池与相互依赖的任务不能一起使用。</p>
<h3 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h3><p>如果必须获得多个锁，那么在设计时必须考虑锁的顺序，尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。</p>
<p>当使用内置锁时，只要没有获得锁，就会永远等待下去，而显式锁则可以指定一个超时时限（显式使用Lock类中的定时tryLock功能），在等待超过该时间后tryLock会返回一个失败信息。</p>
<p>当定时锁失败时，你并不需要知道失败的原因。至少你能记录所发生的失败，以及关于这次操作的其他有用信息。</p>
<p>虽然java6中包含对显式Lock的线程转储和死锁检测等，但内置锁与获得它们所在的线程栈帧是相关联的，而显式的Lock只与获得它的线程相关联。</p>
<h3 id="其他活跃性危险"><a href="#其他活跃性危险" class="headerlink" title="其他活跃性危险"></a>其他活跃性危险</h3><p>要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题，在大多数并发应用程序中，都可以使用默认的线程优先级。</p>
<blockquote>
<p>最常见的活跃性故障就是锁顺序死锁，在设计时应该避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序，最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。</p>
</blockquote>
<h2 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h2><p>首先要保证程序能正确运行，然后仅当程序的性能需求和测试结果要求程序执行得更快时，才应该设法提高它得运行速度，在设计并发得应用程序时，最重要得考虑因素通常并不是将程序的性能提升至极限。</p>
<blockquote>
<p>可伸缩性指的是：当增加计算资源时（例如CPU、内存、存储容量或IO带宽），程序的吞吐量或者处理能力能相应地增加。</p>
</blockquote>
<p>在并发应用程序中针对<strong>可伸缩性</strong>进行设计和调整时所采用地方法与传统地<strong>性能调优</strong>方法截然不同。</p>
<p>当进行性能调优时，其目的通常是用更小的代价来完成相同地工作，例如通过缓存来重用之前计算的结果，或者采用时间复杂度更小的算法。</p>
<p>在进行可伸缩性调优时，其目的是设法将问题地计划并行化，从而能利用更多地计算资源来完成更多地工作。</p>
<p>我们通常会接收每个工作单元执行更长地时间或小号更多的计算资源，以换取应用程序在增加更多资源的情况下处理更高的负载。</p>
<p>对于服务器应用程序来说，“多少”这个方面——可伸缩性、吞吐量和生产量，往往比“多快”这个方面更受重视。</p>
<blockquote>
<p>避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它还运行得不够快</p>
</blockquote>
<p>在大多数性能决策中都包含有多个变量，并且非常依赖于运行环境。在使某个方案比其他方案“更快”之前，首先问自己一些问题：</p>
<ul>
<li><p>“更快”得含义是什么？</p>
</li>
<li><p>该方法在什么条件下运行的更快？在低负载还是高负债的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？</p>
</li>
<li><p>这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？</p>
</li>
<li><p>在其他不同条件的环境中能否使用这里的代码？</p>
</li>
<li><p>在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？</p>
<p>对性能的调优时，一定要有明确的性能需求（这样才能知道什么时候需要调优，）</p>
</li>
</ul>
<p>特别是，当提到并发时，许多开发人员对于哪些地方存在性能问题，哪些方法的运行速度更快，以及哪种方法的可伸缩性更高，往往会存在错误的直觉。</p>
<blockquote>
<p>因此，在对性能的调优时，一定要有明确的性能需求，这样才能知道什么时候需要调优，以及什么时候应该停止，此外还需要一个测试程序以及真实的配置和负载环境。</p>
</blockquote>
<p>在许多优化措施中带来的安全性和可维护性等风险非常高，如果不是必须的话，你通常不想付出这样的代价。</p>
<blockquote>
<p>以测试为基准，不要猜测</p>
</blockquote>
<h3 id="Admdahl定律"><a href="#Admdahl定律" class="headerlink" title="Admdahl定律"></a>Admdahl定律</h3><p>在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。假定F是必须被串行化执行的部分，那么根据Amdahl定律，在包含N个处理器的机器中，最高的加速比为<br>$$<br>Speedup&lt;1&#x2F;(F+(1-F)&#x2F;N)<br>$$<br>当N趋近于无穷大时，最大的加速比趋近于1&#x2F;F。</p>
<p>随着处理器数量的增加，可以很明显的看到，即使串行部分所占的百分比很小，也会极大的限制当增加计算资源时能够提升的吞吐率。</p>
<p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20231218184610849.png" alt="image-20231218184610849"></p>
<p>想要知道串行部分是如何隐藏在应用程序的架构中，可以比较当增加线程时吞吐量的变化，并根据观察到的可伸缩性变化来推断串行部分中的差异。</p>
<h3 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h3><blockquote>
<p>对于为了提升性能而引入的线程来说，并行带来的性能提升必须超过并发导致的开销。</p>
</blockquote>
<p>如果线程频繁地发生阻塞，那么它们将无法使用完整的调度时间片，在程序中发生越多的阻塞（包括阻塞IO，等待获取发生竞争的锁，或者在条件变量上等待），与CPU密集型的程序就会发生越多的上下文切换，从而增加调度开销，并因此而降低吞吐量。</p>
<blockquote>
<p>无阻塞算法有助于减小上下文切换。</p>
</blockquote>
<p>如果内核占用率较高（超过10%），那么通常表示调度活动发生得很频繁，这很可能是由于IO或竞争锁导致的阻塞引起的。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>自旋等待或者通过操作系统挂起被阻塞的线程，这两种方式的效率高低，要取决于上下文切换的开销以及在成功获取锁之前需要等待的时间，如果等待时间较短，则适合采用自旋等待方式，而如果等待时间较长，则适合采用线程挂起方式。有些JVM将根据对历史等待时间的分析数据在两者之间进行选择，但是大多数JVM在等待锁时都只是将线程挂起。</p>
<p>由于锁竞争而导致阻塞时，线程在持有锁时将存在一定的开销：当它释放锁时，必须告诉操作系统恢复运行阻塞的线程。</p>
<h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><p>串行操作会降低可伸缩性，并且上下文切换也会降低性能。在锁上发生竞争时将同时导致这两种问题，因此减少锁的竞争能够提高性能和可伸缩性。</p>
<blockquote>
<p>在并发程序中，对可伸缩型的最主要威胁就是独占方式的资源锁。</p>
</blockquote>
<p>有两个因素将影响在锁上发生竞争的可能性：锁的请求频率，以及每次持有该锁的时间。如果两者的乘积很小，那么大多数获取锁的操作都不会发生竞争。</p>
<blockquote>
<p>有3中方式可以降低锁的竞争程度：</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性</li>
</ul>
</blockquote>
<h4 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h4><p>减小锁的持有时间的方式是降低线程请求锁的频率，这可以通过锁分解和锁分段等技术来实现，在这些技术中将采用多个互相独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况，这些技术能减小锁操作的粒度，并能实现更高的可伸缩性，然而，使用的锁越多，那么发生死锁的风险也就越高。</p>
<p>如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。</p>
<p>在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为锁分段。例如在ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1&#x2F;16，其中第N个散列通由第(N mod 16)个锁来保护。</p>
<h4 id="一些替代独占锁的方法"><a href="#一些替代独占锁的方法" class="headerlink" title="一些替代独占锁的方法"></a>一些替代独占锁的方法</h4><p>第三种降低竞争锁的影响的技术就是放弃使用独占锁，从而有助于使用一种友好并发的方式来管理共享状态，例如：<strong>使用并发容器、读写锁、不可变对象以及原子变量</strong>。</p>
<h4 id="监测CPU的利用率"><a href="#监测CPU的利用率" class="headerlink" title="监测CPU的利用率"></a>监测CPU的利用率</h4><p>如果所有CPU的利用率并不均匀，那么首要目标是进一步找出程序中的并行性，不均匀的利用率表明大多数计算都是由一小组线程完成的，并且应用程序没有利用其他的处理器。</p>
<p>如果CPU没有得到充分利用，通常有以下几种原因：</p>
<ul>
<li>负载不充足</li>
<li>应用程序是IO密集型</li>
<li>外部限制</li>
<li>锁竞争</li>
</ul>
<h3 id="不同Map的性能比较"><a href="#不同Map的性能比较" class="headerlink" title="不同Map的性能比较"></a>不同Map的性能比较</h3><p><img src="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20231221085414384.png" alt="image-20231221085414384"></p>
<h3 id="减少上下文切换的开销"><a href="#减少上下文切换的开销" class="headerlink" title="减少上下文切换的开销"></a>减少上下文切换的开销</h3><blockquote>
<p>以下是一个日志操作线程可能服务时间较长的原因</p>
</blockquote>
<p>操作系统将被阻塞的线程从调度队列中移走并知道IO操作结束，这将比实际IO阻塞的时间更长。当IO操作结束时，可能有其他线程正在执行它们的调度时间片，并且在调度队列中有些线程位于被阻塞线程之前，从而进一步增加服务时间，如果有多个线程在同时记录日志，那么还可能在输出流的锁上发生竞争，这种情况的结果与阻塞IO的情况一样——线程被阻塞并等待锁，然后被线程调度器交换出去。在这种日志操作中包含了IO操作和加锁操作，从而导致上下文切换次数的增多，以及服务时间的增加。</p>
<p>通过将IO操作从处理请求的线程中分离出来，可以缩短处理请求的平均服务时间。</p>
<blockquote>
<p>但前提是不影响最终的正确性。</p>
</blockquote>
<p>通过把IO操作从处理请求的线程转移到一个专门的线程，类似于两种不同救火方案之间的差异：第一种方案是所有人排成一队，通过传递水桶来救火；第二种方案是每个人都拿着一个水桶去救火。在第二种方案中，每个人都可能在水源和着火点上存在更大的竞争（结果导致只能将更少的水传递到着火点），此外救火的效率也更低，因为每个人都在不停的切换模式（装水、跑步、倒水、跑步…），正如中断会干扰人们的工作并降低效率，阻塞和上下文切换同样会干扰线程的正常执行。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多的将侧重点放在吞吐量和可伸缩性上，而不是服务&#x2F;响应时间。</p>
<p>Amdahl定律告诉我们，程序的可伸缩性去觉得在所有代码中必须被串行执行的代码比例。</p>
<p>因为java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过以下方式来提升可伸缩性：</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的粒度</li>
<li>采用非独占的锁或非阻塞锁来代替独占锁</li>
</ul>
<h2 id="并发程序的测试"><a href="#并发程序的测试" class="headerlink" title="并发程序的测试"></a>并发程序的测试</h2><p>在测试并发程序时，所面临的主要挑战在于：潜在错误的发生并不具有确定性，而是随机的。要在测试中将这些故障暴露出来，就需要比普通的串行程序测试覆盖更广的范围并且执行更长的时间。</p>
<p>并发测试大致分为两类。即安全性测试与活跃性测试。安全性指“不发生任何错误的行为”，活跃性指“某个良好的行为终究会发生”（比如不会死锁）</p>
<p>性能测试将衡量典型测试用例中的端到端性能。通常，要获得一组合理的使用场景并不容易，理想情况下，在测试中反映出被测试对象在应用程序中的实际用法。性能测试的第二个目标是根据经验值来调整各种不同的限值，例如线程数量、缓存容量等。这些限值可能依赖于具体平台的特性，因此需要动态的进行配置，而我们通常需要合理地选择这些值，从而使程序能够在更多地系统上良好地运行。</p>
<h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>ReentrantLock并不是一种替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。</p>
<h3 id="Lock与ReentrantLock"><a href="#Lock与ReentrantLock" class="headerlink" title="Lock与ReentrantLock"></a>Lock与ReentrantLock</h3><p>Lock提供一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要创建一种与内置锁如此相似的新加锁机制？在大多数情况下，内置锁都能很好地工作，但在功能上存在一些局限性，例如无法中断一个正在等待获取锁的线程，或者请求获取一个锁时不想无限地等待下去。</p>
<p>内置锁必须在获取该锁地代码块钟释放，这就简化了编码工作，并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构地加锁规则。这些都不是抛弃使用synchronized的原因，而是在某些场景下，更灵活的锁策略能提供更好的活跃性和性能，但是也更危险，容易因异常或疏忽而忘了释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">...</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">//这里最好不要有其他代码防止出现异常时lock无法释放</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// update object state</span></span><br><span class="line">    <span class="comment">// catch exceptions and restore invariants if necessary</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。</p>
<p>lockInterruptibly方法能够在获得锁的同时保持对中断的响应，并且由于她包含在Lock中，因此无须创建</p>
<h3 id="性能考虑因素"><a href="#性能考虑因素" class="headerlink" title="性能考虑因素"></a>性能考虑因素</h3><p>如果有越多的资源被耗费在锁的管理和调度上，那么应用程序得到的资源就越少。锁的实现方式越好，将需要越少的系统调用和上下文切换，并且在共享内存总线上的内存同步通信量也越少，而一些耗时的操作将占用应用程序的计算资源。</p>
<p>在Java5中，ReentrantLock能提供更高的吞吐量，但在Java6中，二者的吞吐量非常接近。</p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。在实际情况中，统计上地公平性保证——确保被阻塞地线程能最终获得锁，通常已经够用了，并且实际开销也小得多。有些算法依赖于公平得排队算法以确保它们得正确性，但这些算法并不常见。在大多数情况下，非公平锁的性能要高于公平锁的性能。</p>
<p>不必要的化，不要为公平性付出代价。</p>
<p>当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。</p>
<h3 id="在Synchronized和ReentrantLock之间进行选择"><a href="#在Synchronized和ReentrantLock之间进行选择" class="headerlink" title="在Synchronized和ReentrantLock之间进行选择"></a>在Synchronized和ReentrantLock之间进行选择</h3><p>仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock。这些功能包括，可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁，否则还是应该优先使用synchronized。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>在这种情况下就可以使用读写锁：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。</p>
<blockquote>
<p>和缓存的情况很像</p>
</blockquote>
<p>读写锁是一种性能优化措施，在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读写锁能提高性能。而在其他情况下，读写锁的性能比独占锁的性能要略差一些，这是因为它们的复杂性更高。因为读写锁是用不同的Lock来锁读写，如果读写锁不能带来优势，那么可以直接换成独占锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadWriteMap</span><span class="params">(Map&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do the same for remove(), putAll(), clear()</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do the same for other read-only Map methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h2><p>对于并发对象上依赖状态的方法（例如连接池必须非空），虽然有时候在前提条件不满足的情况下不会失败，但通常有一种更好的方法，即——等待前提条件变为真。</p>
<p>依赖状态的操作可以一直阻塞直到可以继续执行，这比使它们先失败再实现起来要更为方便且更不易出错。内置的条件队列可以使线程一直阻塞，直到对象进入某个进程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒它们。</p>
<p>通过轮询与休眠等方式来（勉强地）解决状态依赖性问题。</p>
<h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><p>“条件队列”这个名字来源于:它使得一组线程(称之为等待线程集合)能够通过某种方式来等待特定的条件变成真。传统队列的元素是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。</p>
<p>但要注意:与使用“休眠”的有界缓存相比，条件队列并没有改变原来的语义。它只是在多个方面进行了优化:CPU 效率、上下文切换开销和响应性等。如果某个能无法通过“轮询和休眠”来实现，那么使用条件队列也无法实现9，但条件队列使得在表达和管理状态依赖性时更加简单和高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">BaseBoundedBuffer</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-full (!isFull())</span></span><br><span class="line">    <span class="comment">// CONDITION PREDICATE: not-empty (!isEmpty())</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBuffer</span><span class="params">(<span class="type">int</span> size)</span> &#123; <span class="built_in">super</span>(size); &#125;</span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-full</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">        	wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BLOCKS-UNTIL: not-empty</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">        	wait();</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，BoundedBuffer 变得足够好了，不仅简单易用，而且实现了明晰的状态依赖性管理在产品的正式版本中还应包括限时版本的 put和 take，这样当阻塞操作不能在预计时间内完成时，可以因超时而返回。通过使用定时版本的 Object.wait，可以很容易实现这些方法。</p>
<h3 id="使用条件队列"><a href="#使用条件队列" class="headerlink" title="使用条件队列"></a>使用条件队列</h3><p>在条件等待种存在一种重要的三元关系，包括加锁，wait方法和一个条件谓词。在条件谓词种包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象与条件队列对象（即调用wait和notify等方法所在的对象）必须是同一个对象。</p>
<p>每当线程从wait种唤醒时，都必须再次测试条件谓词，如果条件谓词不为真，那么久继续等待或者失败。由于线程在条件谓词不为真的情况下也可以反复地醒来，因此必须在一个循环中调用wait，并在每次迭代种都测试条件谓词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// condition predicate must be guarded by lock</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!conditionPredicate())</span><br><span class="line">        	lock.wait();</span><br><span class="line">        <span class="comment">// object is now in desired state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用条件等待时(例如Object.wait或Condition.await)</p>
<ul>
<li>通常都有一个条件谓词——包括一些对象状态的测试，线程在执行前必须首先通过这些测试。</li>
<li>在调用wait之前测试条件谓词，并且从wat中返回时再次进行测试。</li>
<li>在个循环中调用wait。</li>
<li>确保使用与条件队列相关的锁来保护构成条件谓词的客不状态变量</li>
<li>当调用 wait、notify或notifyAll 等方法时，一定要持有与条件队列相关的锁。</li>
<li>在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。</li>
</ul>
<blockquote>
<p>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://enosmith.com">邓晖</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://enosmith.com/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="/2023/05/23/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/24/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/" title="性能调优实战"><img class="cover" src="/img/default_cover4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">性能调优实战</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/14/%E4%B8%80%E6%97%A5%E4%B8%80%E6%80%9D/" title="一日一思"><img class="cover" src="/2023/05/14/%E4%B8%80%E6%97%A5%E4%B8%80%E6%80%9D/cover.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">一日一思</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">邓晖</div><div class="author-info__description">亲疏随缘，不负不欠</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Enosmith"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Enosmith" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/denghui19890703@hotmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">一个普通又不普通的程序员，喜欢健身、音乐、摄影、美食、猫，会在这里记录生活，分享感悟，也会发发牢骚，吐槽不快，总之，这里是我的树洞。如果你刚好认识我，请帮我保守这一隐秘的角落，谢谢。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">利用命令行查询线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">线程的执行顺序是不确定的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">两种异步模型与深度解析Future接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">无返回结果的异步模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">有返回结果的异步模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">深度解析Future接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">FutureTask类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">高并发系统实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">高并发关键指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">2.2.</span> <span class="toc-text">分布式的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">微服务的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoin%E6%A1%86%E6%9E%B6"><span class="toc-number">2.4.</span> <span class="toc-text">ForkJoin框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">工作窃取算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoin%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">ForkJoin示例程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-concurrency-in-practice"><span class="toc-number">3.</span> <span class="toc-text">java-concurrency-in-practice</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Preface"><span class="toc-number">3.1.</span> <span class="toc-text">Preface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-use-this-book"><span class="toc-number">3.2.</span> <span class="toc-text">How to use this book</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">3.3.</span> <span class="toc-text">线程的风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.4.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.4.1.</span> <span class="toc-text">什么是线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.4.2.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E6%80%81%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">竞态状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">复合操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.3.</span> <span class="toc-text">加锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E9%94%81"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">内置锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reentrancy-%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">Reentrancy(重入锁)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guarding-state-with-locks%EF%BC%88%E7%94%A8%E9%94%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">3.4.4.</span> <span class="toc-text">Guarding state with locks（用锁来保护状态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">3.4.5.</span> <span class="toc-text">活跃性与性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">3.5.</span> <span class="toc-text">对象共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">失效数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nonatomic-64-bit-operations%EF%BC%88%E9%9D%9E%E5%8E%9F%E5%AD%90%E7%9A%8464%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Nonatomic 64-bit operations（非原子的64位操作）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">加锁和可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">volatile变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%92%8C%E9%80%B8%E5%87%BA"><span class="toc-number">3.5.2.</span> <span class="toc-text">发布和逸出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">安全的对象构造过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD"><span class="toc-number">3.5.3.</span> <span class="toc-text">线程封闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%B1%BB"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">ThreadLocal类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.5.4.</span> <span class="toc-text">不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Final%E5%9F%9F"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">Final域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83"><span class="toc-number">3.5.5.</span> <span class="toc-text">安全发布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8F%91%E5%B8%83%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">不正确的发布：正确的对象被破坏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">不可变对象与初始化安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">安全发布的常用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%AE%9E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.5.4.</span> <span class="toc-text">事实不可变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.5.5.</span> <span class="toc-text">可变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%9C%B0%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.5.6.</span> <span class="toc-text">安全地共享对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">3.6.</span> <span class="toc-text">对象的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">设计线程安全的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%90%8C%E6%AD%A5%E9%9C%80%E6%B1%82"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">收集同步需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%8A%B6%E6%80%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">依赖状态的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B0%81%E9%97%AD"><span class="toc-number">3.6.2.</span> <span class="toc-text">实例封闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%9B%91%E8%A7%86%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">java监视器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">3.6.3.</span> <span class="toc-text">线程安全性的委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A7%94%E6%89%98%E7%9A%84%E8%BD%A6%E8%BE%86%E8%BF%BD%E8%B8%AA%E5%99%A8"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">基于委托的车辆追踪器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%A7%94%E6%89%98%E5%A4%B1%E6%95%88%E6%97%B6"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">当委托失效时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8F%91%E5%B8%83%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%A6%E8%BE%86%E8%BF%BD%E8%B8%AA%E5%99%A8"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">示例：发布状态的车辆追踪器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%8E%B0%E6%9C%89%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="toc-number">3.6.4.</span> <span class="toc-text">在现有的线程安全类中添加功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">客户端加锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5%E6%96%87%E6%A1%A3%E5%8C%96"><span class="toc-number">3.6.5.</span> <span class="toc-text">同步策略文档化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97"><span class="toc-number">3.7.</span> <span class="toc-text">基础构建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">3.7.1.</span> <span class="toc-text">同步容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">同步容器类的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8EConcurrentModificationException"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">迭代器与ConcurrentModificationException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.7.1.3.</span> <span class="toc-text">隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%8E%9F%E5%AD%90Map%E6%93%8D%E4%BD%9C"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">额外的原子Map操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">3.7.3.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%AF%86%E5%8F%96"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">双端队列和工作密取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.4.</span> <span class="toc-text">阻塞方法与中断方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.7.5.</span> <span class="toc-text">同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E9%94%81%EF%BC%88latch%EF%BC%89"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">闭锁（latch）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask"><span class="toc-number">3.7.5.2.</span> <span class="toc-text">futuretask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88semaphore%EF%BC%89"><span class="toc-number">3.7.5.3.</span> <span class="toc-text">信号量（semaphore）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%EF%BC%88barrier%EF%BC%89"><span class="toc-number">3.7.5.4.</span> <span class="toc-text">栅栏（barrier）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E4%B8%94%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98"><span class="toc-number">3.7.5.5.</span> <span class="toc-text">构建高效且可伸缩的结果缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%B0%8F%E7%BB%93"><span class="toc-number">3.7.6.</span> <span class="toc-text">第一部分小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">3.8.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.1.</span> <span class="toc-text">在线程中执行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%9C%B0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">串行地执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E4%B8%BA%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">显式的为任务创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">无限创建线程的不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor%E6%A1%86%E6%9E%B6"><span class="toc-number">3.8.2.</span> <span class="toc-text">Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">执行策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.8.2.2.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.8.2.3.</span> <span class="toc-text">Executor的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.2.4.</span> <span class="toc-text">延迟任务与周期任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="toc-number">3.8.3.</span> <span class="toc-text">找出可利用的并行性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BB%BB%E5%8A%A1Callable%E5%92%8CFuture"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">携带结果的任务Callable和Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BC%82%E6%9E%84%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%8C%96%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">在异构任务并行化中存在的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletionService%EF%BC%9AExecution%E4%B8%8EBlockingQueue"><span class="toc-number">3.8.3.3.</span> <span class="toc-text">CompletionService：Execution与BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%99%90"><span class="toc-number">3.8.3.4.</span> <span class="toc-text">为任务设置时限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">3.9.</span> <span class="toc-text">取消与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88"><span class="toc-number">3.9.1.</span> <span class="toc-text">任务取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AD%96%E7%95%A5"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">中断策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">3.9.1.3.</span> <span class="toc-text">响应中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87future%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8F%96%E6%B6%88"><span class="toc-number">3.9.1.4.</span> <span class="toc-text">通过future来实现取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">3.9.1.5.</span> <span class="toc-text">处理不可中断的阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.9.2.</span> <span class="toc-text">停止基于线程的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownNow%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">shutdownNow的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">3.9.3.</span> <span class="toc-text">处理非正常的线程终止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.10.</span> <span class="toc-text">线程池的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.10.1.</span> <span class="toc-text">设置线程池的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEThreadPoolExecutor"><span class="toc-number">3.10.2.</span> <span class="toc-text">配置ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="toc-number">3.10.2.1.</span> <span class="toc-text">线程工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95ThreadPoolExecutor"><span class="toc-number">3.10.2.2.</span> <span class="toc-text">扩展ThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9"><span class="toc-number">3.11.</span> <span class="toc-text">避免活跃性危险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.11.1.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E9%A1%BA%E5%BA%8F%E6%AD%BB%E9%94%81"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">锁顺序死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%9A%84%E9%94%81%E9%A1%BA%E5%BA%8F%E6%AD%BB%E9%94%81"><span class="toc-number">3.11.1.2.</span> <span class="toc-text">动态的锁顺序死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%E4%B8%8E%E8%AF%8A%E6%96%AD"><span class="toc-number">3.11.2.</span> <span class="toc-text">死锁的避免与诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9"><span class="toc-number">3.11.3.</span> <span class="toc-text">其他活跃性危险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">3.12.</span> <span class="toc-text">性能与可伸缩性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Admdahl%E5%AE%9A%E5%BE%8B"><span class="toc-number">3.12.1.</span> <span class="toc-text">Admdahl定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">3.12.2.</span> <span class="toc-text">线程引入的开销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">3.12.2.1.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89"><span class="toc-number">3.12.3.</span> <span class="toc-text">减少锁的竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">3.12.3.1.</span> <span class="toc-text">减小锁的粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9B%BF%E4%BB%A3%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.12.3.2.</span> <span class="toc-text">一些替代独占锁的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%B5%8BCPU%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">3.12.3.3.</span> <span class="toc-text">监测CPU的利用率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8CMap%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">3.12.4.</span> <span class="toc-text">不同Map的性能比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">3.12.5.</span> <span class="toc-text">减少上下文切换的开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.12.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">3.13.</span> <span class="toc-text">并发程序的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-number">3.14.</span> <span class="toc-text">显式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E4%B8%8EReentrantLock"><span class="toc-number">3.14.1.</span> <span class="toc-text">Lock与ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">3.14.2.</span> <span class="toc-text">性能考虑因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="toc-number">3.14.3.</span> <span class="toc-text">公平性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Synchronized%E5%92%8CReentrantLock%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9"><span class="toc-number">3.14.4.</span> <span class="toc-text">在Synchronized和ReentrantLock之间进行选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.14.5.</span> <span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">3.15.</span> <span class="toc-text">构建自定义的同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">3.15.1.</span> <span class="toc-text">条件队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">3.15.2.</span> <span class="toc-text">使用条件队列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/%E5%A4%96%E5%8D%8F%E8%A7%84%E8%8C%83%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%BF%83%E5%BE%97/" title="外协规范化开发流程及心得"><img src="/img/default_cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="外协规范化开发流程及心得"/></a><div class="content"><a class="title" href="/2023/09/29/%E5%A4%96%E5%8D%8F%E8%A7%84%E8%8C%83%E5%8C%96%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%BF%83%E5%BE%97/" title="外协规范化开发流程及心得">外协规范化开发流程及心得</a><time datetime="2023-09-29T10:04:50.000Z" title="Created 2023-09-29 18:04:50">2023-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/" title="分布式组件学习"><img src="/img/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式组件学习"/></a><div class="content"><a class="title" href="/2023/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/" title="分布式组件学习">分布式组件学习</a><time datetime="2023-08-17T07:24:34.000Z" title="Created 2023-08-17 15:24:34">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="数据密集型应用系统设计"><img src="/img/default_cover10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据密集型应用系统设计"/></a><div class="content"><a class="title" href="/2023/08/11/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="数据密集型应用系统设计">数据密集型应用系统设计</a><time datetime="2023-08-11T14:40:47.000Z" title="Created 2023-08-11 22:40:47">2023-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/08/%E8%81%8C%E5%9C%BA-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" title="职场/项目管理"><img src="/img/default_cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="职场/项目管理"/></a><div class="content"><a class="title" href="/2023/08/08/%E8%81%8C%E5%9C%BA-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" title="职场/项目管理">职场/项目管理</a><time datetime="2023-08-08T02:28:01.000Z" title="Created 2023-08-08 10:28:01">2023-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/19/%E4%BA%BA%E4%BB%B6/" title="人件(pepoleware)"><img src="/img/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="人件(pepoleware)"/></a><div class="content"><a class="title" href="/2023/07/19/%E4%BA%BA%E4%BB%B6/" title="人件(pepoleware)">人件(pepoleware)</a><time datetime="2023-07-19T01:13:10.000Z" title="Created 2023-07-19 09:13:10">2023-07-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 邓晖</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>